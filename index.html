<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>å£°ç½‘ RTC åŒå·¥å¯¹è¯å®¢æˆ·ç«¯</title>
    <script src="https://download.agora.io/sdk/release/AgoraRTC_N-4.20.0.js"></script>
    <script src="web_uid_validator.js"></script>
    <script src="web_subscription_manager.js"></script>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(135deg, #5a67d8 0%, #805ad5 100%);
        min-height: 100vh;
        display: flex;
        justify-content: center;
        align-items: center;
        color: #1a202c;
        padding: 24px;
      }

      .container {
        width: 100%;
        max-width: 900px;
        background: rgba(255, 255, 255, 0.96);
        border-radius: 20px;
        padding: 32px;
        box-shadow: 0 20px 60px rgba(67, 56, 202, 0.18);
      }

      header {
        text-align: center;
        margin-bottom: 24px;
      }

      header h1 {
        font-size: 2.2rem;
        color: #2d3748;
        margin-bottom: 8px;
      }

      header p {
        color: #4a5568;
      }

      .status-panel {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        gap: 16px;
        margin-bottom: 24px;
      }

      .status-card {
        background: linear-gradient(135deg, #edf2f7 0%, #e2e8f0 100%);
        border-radius: 14px;
        padding: 18px;
        border: 1px solid #cbd5f5;
      }

      .status-card h2 {
        font-size: 1rem;
        color: #2b6cb0;
        margin-bottom: 8px;
        text-transform: uppercase;
        letter-spacing: 0.06em;
      }

      .status-value {
        font-size: 1.2rem;
        font-weight: 600;
      }

      .status-value.online {
        color: #2f855a;
      }

      .status-value.offline {
        color: #c53030;
      }

      .status-value.idle {
        color: #b7791f;
      }

      .controls {
        display: flex;
        flex-wrap: wrap;
        gap: 16px;
        margin-bottom: 24px;
        justify-content: center;
      }

      button {
        padding: 12px 28px;
        border: none;
        border-radius: 999px;
        font-size: 1rem;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.25s ease;
        color: #fff;
      }

      button.primary {
        background: linear-gradient(135deg, #48bb78, #38a169);
      }

      button.primary:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }

      button.danger {
        background: linear-gradient(135deg, #f56565, #e53e3e);
      }

      button.danger:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }

      .meter {
        background: #edf2f7;
        border-radius: 14px;
        padding: 12px 18px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        font-size: 0.95rem;
        color: #4a5568;
      }

      .meter span {
        font-weight: 600;
        color: #2d3748;
      }

      .meter-bar {
        margin-top: 8px;
        width: 180px;
        height: 10px;
        background: #e2e8f0;
        border-radius: 999px;
        overflow: hidden;
      }

      .meter-fill {
        height: 100%;
        width: 0%;
        background: linear-gradient(135deg, #63b3ed, #3182ce);
        transition: width 0.1s ease;
      }

      .conversation-log {
        background: #f7fafc;
        border-radius: 14px;
        border: 1px solid #e2e8f0;
        padding: 18px;
        max-height: 260px;
        overflow-y: auto;
      }

      .log-entry {
        margin-bottom: 12px;
        padding-bottom: 12px;
        border-bottom: 1px dashed rgba(160, 174, 192, 0.5);
      }

      .log-entry:last-child {
        border-bottom: none;
      }

      .log-entry time {
        display: block;
        font-size: 0.8rem;
        color: #718096;
        margin-bottom: 4px;
      }

      .log-entry strong {
        display: inline-block;
        min-width: 70px;
        color: #2b6cb0;
      }

      .volume-control {
        display: flex;
        align-items: center;
        gap: 12px;
        justify-content: center;
        margin-top: 8px;
      }

      .volume-control label {
        font-weight: 600;
        color: #2d3748;
      }

      .volume-control input {
        width: 220px;
      }

      footer {
        margin-top: 24px;
        text-align: center;
        font-size: 0.85rem;
        color: #4a5568;
      }

      footer code {
        background: #edf2f7;
        padding: 2px 6px;
        border-radius: 6px;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <header>
        <h1>å£°ç½‘ RTC åŒå·¥å¯¹è¯å®¢æˆ·ç«¯</h1>
        <p>æµè§ˆå™¨ç›´æ¥åŠ å…¥å£°ç½‘é¢‘é“ï¼Œä¸Šè¡Œéº¦å…‹é£ã€ä¸‹è¡Œ Bot éŸ³é¢‘</p>
      </header>

      <section class="status-panel">
        <div class="status-card">
          <h2>è¿æ¥çŠ¶æ€</h2>
          <div id="connectionStatus" class="status-value offline">æœªè¿æ¥</div>
          <p id="statusHint">ç‚¹å‡»å¼€å§‹å¯¹è¯å³å¯è¿æ¥å£°ç½‘</p>
        </div>
        <div class="status-card">
          <h2>é¢‘é“ä¿¡æ¯</h2>
          <div class="status-value">
            <div>é¢‘é“ï¼š<span id="channelName">-</span></div>
            <div>æœ¬åœ° UIDï¼š<span id="localUid">-</span></div>
          </div>
        </div>
        <div class="status-card">
          <h2>Bot çŠ¶æ€</h2>
          <div class="status-value">
            <div>è¿œç«¯ UIDï¼š<span id="remoteUid">-</span></div>
            <div>éŸ³é‡ï¼š<span id="remoteVolume">70%</span></div>
          </div>
        </div>
      </section>

      <section class="controls">
        <button id="connectButton" class="primary">å¼€å§‹å¯¹è¯</button>
        <button id="disconnectButton" class="danger" disabled>æ–­å¼€è¿æ¥</button>
      </section>

      <section class="meter">
        <div>
          <span>éº¦å…‹é£ç”µå¹³</span>
          <div class="meter-bar">
            <div id="micBar" class="meter-fill"></div>
          </div>
        </div>
        <div>
          <span id="micLevel">0%</span>
        </div>
      </section>

      <div class="volume-control">
        <label for="volumeSlider">Bot éŸ³é‡</label>
        <input id="volumeSlider" type="range" min="0" max="100" value="70" />
      </div>

      <section class="conversation-log" id="logContainer"></section>

      <div id="remoteAudio"></div>

      <footer>
        <div>
          è°ƒè¯•å‘½ä»¤ï¼š<code
            >curl https://cityuantifraud.com/api/agora/config</code
          >
        </div>
      </footer>
    </div>

    <script>
      const client = AgoraRTC.createClient({ mode: "rtc", codec: "vp8" });
      let localTrack = null;
      let remoteAudioTrack = null;
      let agoraConfigCache = null;
      const backendBaseUrl = "https://cityuantifraud.com";
      let isConnecting = false;
      let subscriptionManager = null;
      let audioContext = null;
      let analyser = null;
      let micDataArray = null;
      let meterAnimation = null;

      const elements = {
        connectionStatus: document.getElementById("connectionStatus"),
        statusHint: document.getElementById("statusHint"),
        channelName: document.getElementById("channelName"),
        localUid: document.getElementById("localUid"),
        remoteUid: document.getElementById("remoteUid"),
        remoteVolume: document.getElementById("remoteVolume"),
        connectButton: document.getElementById("connectButton"),
        disconnectButton: document.getElementById("disconnectButton"),
        volumeSlider: document.getElementById("volumeSlider"),
        micLevel: document.getElementById("micLevel"),
        micBar: document.getElementById("micBar"),
        logContainer: document.getElementById("logContainer"),
      };

      function log(source, message, type = "info") {
        const entry = document.createElement("div");
        entry.className = "log-entry";
        const timestamp = new Date().toLocaleTimeString();
        entry.innerHTML = `
          <time>${timestamp}</time>
          <div><strong>${source}</strong>${message}</div>
        `;
        if (type === "error") {
          entry.style.color = "#c53030";
        } else if (type === "success") {
          entry.style.color = "#2f855a";
        }
        elements.logContainer.appendChild(entry);
        elements.logContainer.scrollTop = elements.logContainer.scrollHeight;
      }

      function setConnectionState(state, hint) {
        elements.connectionStatus.classList.remove("online", "offline", "idle");
        elements.connectionStatus.classList.add(state);
        elements.connectionStatus.textContent =
          state === "online"
            ? "å·²è¿æ¥"
            : state === "offline"
            ? "æœªè¿æ¥"
            : "å‡†å¤‡ä¸­";
        if (hint) {
          elements.statusHint.textContent = hint;
        }
      }

      async function fetchAgoraConfig(role = "publisher") {
        if (role === "publisher" && agoraConfigCache) {
          return agoraConfigCache;
        }
        const url = new URL("/api/agora/config", backendBaseUrl);
        url.searchParams.set("role", role);
        const response = await fetch(url.toString(), {
          method: "GET",
          headers: { "Content-Type": "application/json" },
        });
        if (!response.ok) {
          throw new Error(`åç«¯æ¥å£è¿”å› ${response.status}`);
        }
        const config = await response.json();
        if (!config || !config.appId) {
          throw new Error("åç«¯ç¼ºå°‘å£°ç½‘ App ID");
        }

        // UIDé…ç½®éªŒè¯
        const validationResult = WebUIDValidator.validateConfiguration(config);
        if (!validationResult.isValid) {
          console.error("[CONFIG] UIDé…ç½®éªŒè¯å¤±è´¥:", validationResult.errors);
          throw new Error(`UIDé…ç½®æ— æ•ˆ: ${validationResult.errors.join(", ")}`);
        }

        if (validationResult.warnings.length > 0) {
          console.warn("[CONFIG] UIDé…ç½®è­¦å‘Š:", validationResult.warnings);
        }

        // è®°å½•UIDä¿¡æ¯
        WebUIDValidator.logUIDInfo("é…ç½®éªŒè¯", config.botUid, {
          userUID: config.uid,
          channel: config.channel,
        });

        if (role === "publisher") {
          agoraConfigCache = config;
        }
        return config;
      }

      function startMicMeter(track) {
        try {
          const streamTrack = track.getMediaStreamTrack();
          if (!streamTrack) {
            return;
          }
          audioContext = new (window.AudioContext ||
            window.webkitAudioContext)();
          const source = audioContext.createMediaStreamSource(
            new MediaStream([streamTrack])
          );
          analyser = audioContext.createAnalyser();
          analyser.fftSize = 256;
          const bufferLength = analyser.frequencyBinCount;
          micDataArray = new Uint8Array(bufferLength);
          source.connect(analyser);

          const update = () => {
            analyser.getByteTimeDomainData(micDataArray);
            let sum = 0;
            for (let i = 0; i < micDataArray.length; i += 1) {
              const value = micDataArray[i] - 128;
              sum += value * value;
            }
            const rms = Math.sqrt(sum / micDataArray.length);
            const level = Math.min(
              100,
              Math.max(0, Math.round((rms / 128) * 100))
            );
            elements.micLevel.textContent = `${level}%`;
            if (elements.micBar) {
              elements.micBar.style.width = `${level}%`;
            }
            meterAnimation = requestAnimationFrame(update);
          };
          update();
        } catch (error) {
          log("ç³»ç»Ÿ", `éº¦å…‹é£ç”µå¹³ç›‘æ§å¼‚å¸¸: ${error.message}`);
        }
      }

      function stopMicMeter() {
        if (meterAnimation) {
          cancelAnimationFrame(meterAnimation);
          meterAnimation = null;
        }
        if (audioContext) {
          audioContext.close();
          audioContext = null;
        }
        analyser = null;
        micDataArray = null;
        elements.micLevel.textContent = "0%";
        if (elements.micBar) {
          elements.micBar.style.width = "0%";
        }
      }

      async function connect() {
        if (isConnecting) {
          return;
        }
        isConnecting = true;
        setConnectionState("idle", "æ­£åœ¨åˆå§‹åŒ–å£°ç½‘é€šé“...");
        elements.connectButton.disabled = true;
        log("ç³»ç»Ÿ", "å‡†å¤‡è¿æ¥å£°ç½‘ RTC...");

        try {
          const config = await fetchAgoraConfig("publisher");
          console.log("[DEBUG] è·å–åˆ°çš„Agoraé…ç½®:", {
            appId: config.appId,
            channel: config.channel,
            uid: config.uid,
            botUid: config.botUid,
            token: config.token
              ? `${config.token.substring(0, 20)}...`
              : "null",
          });
          elements.localUid.textContent = config.uid || "-";
          elements.channelName.textContent = config.channel || "-";

          if (client.connectionState !== "DISCONNECTED") {
            await client.leave().catch(() => {});
          }

          await client.join(
            config.appId,
            config.channel,
            config.token || null,
            config.uid || null
          );
          log("å£°ç½‘", `å·²åŠ å…¥é¢‘é“ ${config.channel}`);

          // åˆå§‹åŒ–è®¢é˜…ç®¡ç†å™¨ - å£°ç½‘æŠ€æœ¯æ”¯æŒå»ºè®®ï¼šæ˜¾å¼è®¢é˜…ç¡®ä¿å…¼å®¹æ€§
          subscriptionManager = new WebSubscriptionManager(client, {
            maxRetryAttempts: 3,
            retryDelay: 2000,
            enableAutoSubscribe: true,
            logLevel: "info",
          });

          // è®¾ç½®è®¢é˜…ç®¡ç†å™¨å›è°ƒ
          subscriptionManager.onSubscriptionSuccess = (
            uid,
            mediaType,
            result
          ) => {
            console.log(`[SUBSCRIPTION] âœ… è®¢é˜…æˆåŠŸ: ${uid} (${mediaType})`);
            log(
              "è®¢é˜…",
              `æˆåŠŸè®¢é˜…ç”¨æˆ· ${uid} çš„${
                mediaType === "audio" ? "éŸ³é¢‘" : "è§†é¢‘"
              }æµ`
            );

            // ç‰¹åˆ«å¤„ç†Botç”¨æˆ·çš„éŸ³é¢‘è®¢é˜…
            if (WebUIDValidator.isBotUser(uid) && mediaType === "audio") {
              console.log(`[SUBSCRIPTION] ğŸ¤– Botç”¨æˆ·éŸ³é¢‘è®¢é˜…æˆåŠŸï¼Œå¼€å§‹æ’­æ”¾`);
              if (result && result.play) {
                result.play();
              }
            }
          };

          subscriptionManager.onSubscriptionFailed = (
            uid,
            mediaType,
            error
          ) => {
            console.error(
              `[SUBSCRIPTION] âŒ è®¢é˜…å¤±è´¥: ${uid} (${mediaType})`,
              error
            );
            log(
              "è®¢é˜…",
              `è®¢é˜…ç”¨æˆ· ${uid} çš„${
                mediaType === "audio" ? "éŸ³é¢‘" : "è§†é¢‘"
              }æµå¤±è´¥: ${error.message}`,
              "error"
            );
          };

          subscriptionManager.onSubscriptionStateChanged = (
            uid,
            mediaType,
            state
          ) => {
            console.log(
              `[SUBSCRIPTION] ğŸ”„ è®¢é˜…çŠ¶æ€å˜åŒ–: ${uid} (${mediaType}) -> ${state}`
            );

            // æ›´æ–°UIæ˜¾ç¤º
            if (WebUIDValidator.isBotUser(uid) && mediaType === "audio") {
              const stateText =
                {
                  not_subscribed: "æœªè®¢é˜…",
                  subscribing: "è®¢é˜…ä¸­",
                  subscribed: "å·²è®¢é˜…",
                  subscription_failed: "è®¢é˜…å¤±è´¥",
                  unsubscribing: "å–æ¶ˆè®¢é˜…ä¸­",
                }[state] || state;

              elements.remoteUid.textContent = `Bot(${uid}) - ${stateText}`;
            }
          };

          console.log("[SUBSCRIPTION] è®¢é˜…ç®¡ç†å™¨åˆå§‹åŒ–å®Œæˆï¼Œå·²è®¾ç½®å›è°ƒå‡½æ•°");

          // [DEBUG] æ£€æŸ¥å½“å‰è¿œç«¯ç”¨æˆ·
          console.log("[DEBUG] å½“å‰è¿œç«¯ç”¨æˆ·:", client.remoteUsers);
          console.log("[DEBUG] è¿œç«¯ç”¨æˆ·æ•°é‡:", client.remoteUsers.length);
          client.remoteUsers.forEach((user) => {
            console.log("[DEBUG] è¿œç«¯ç”¨æˆ·è¯¦æƒ…:", {
              uid: user.uid,
              hasAudio: user.hasAudio,
              hasVideo: user.hasVideo,
            });
          });

          // [AUDIO_FLOW] æ£€æŸ¥éº¦å…‹é£æƒé™å’Œè®¾å¤‡
          try {
            const devices = await AgoraRTC.getDevices();
            const audioInputs = devices.filter(
              (device) => device.kind === "audioinput"
            );
            console.log(
              "[AUDIO_FLOW] å¯ç”¨éŸ³é¢‘è¾“å…¥è®¾å¤‡:",
              audioInputs.map((d) => ({ id: d.deviceId, label: d.label }))
            );

            if (audioInputs.length === 0) {
              console.warn("[AUDIO_FLOW] è­¦å‘Š: æœªæ£€æµ‹åˆ°éŸ³é¢‘è¾“å…¥è®¾å¤‡");
            }
          } catch (error) {
            console.error("[AUDIO_FLOW] è·å–éŸ³é¢‘è®¾å¤‡å¤±è´¥:", error);
          }

          console.log("[AUDIO_FLOW] å¼€å§‹åˆ›å»ºéº¦å…‹é£éŸ³é¢‘è½¨é“...");
          localTrack = await AgoraRTC.createMicrophoneAudioTrack({
            encoderConfig: {
              sampleRate: 48000,
              stereo: false,
            },
          });

          // [AUDIO_FLOW] éŸ³é¢‘è½¨é“åˆ›å»ºæˆåŠŸè°ƒè¯•æ—¥å¿—
          console.log("[AUDIO_FLOW] éº¦å…‹é£éŸ³é¢‘è½¨é“å·²åˆ›å»º:", {
            trackId: localTrack.getTrackId(),
            enabled: localTrack.enabled,
            muted: localTrack.muted,
            sampleRate: 48000,
          });

          await client.publish(localTrack);

          // [AUDIO_FLOW] éŸ³é¢‘å‘å¸ƒæˆåŠŸè°ƒè¯•æ—¥å¿—
          console.log("[AUDIO_FLOW] æœ¬åœ°éŸ³é¢‘å·²å‘å¸ƒåˆ°å£°ç½‘:", {
            trackId: localTrack.getTrackId(),
            published: true,
            clientState: client.connectionState,
          });

          log("å£°ç½‘", "æœ¬åœ°éŸ³é¢‘å·²å‘å¸ƒ");

          // [AUDIO_FLOW] æ·»åŠ éŸ³é¢‘æ•°æ®å¤„ç†å™¨ç›‘å¬éŸ³é¢‘æµ
          let audioFrameCounter = 0;
          try {
            const processor = {
              process: (audioBuffer) => {
                audioFrameCounter++;
                if (audioFrameCounter % 100 === 0) {
                  console.log(
                    "[AUDIO_FLOW] éŸ³é¢‘æ•°æ®æµç»å£°ç½‘SDK (ç¬¬" +
                      audioFrameCounter +
                      "å¸§):",
                    {
                      sampleRate: audioBuffer.sampleRate,
                      numberOfChannels: audioBuffer.numberOfChannels,
                      length: audioBuffer.length,
                      timestamp: Date.now(),
                    }
                  );
                }
                return audioBuffer;
              },
            };

            if (localTrack.pipe && typeof localTrack.pipe === "function") {
              localTrack.pipe(processor);
              console.log("[AUDIO_FLOW] éŸ³é¢‘å¤„ç†å™¨å·²æ·»åŠ åˆ°æœ¬åœ°è½¨é“");
            } else {
              console.log(
                "[AUDIO_FLOW] æœ¬åœ°è½¨é“ä¸æ”¯æŒpipeæ–¹æ³•ï¼Œå°è¯•å…¶ä»–ç›‘å¬æ–¹å¼"
              );
            }
          } catch (error) {
            console.log("[AUDIO_FLOW] æ·»åŠ éŸ³é¢‘å¤„ç†å™¨å¤±è´¥:", error.message);
          }

          startMicMeter(localTrack);

          // å¤„ç† Autoplay é™åˆ¶
          AgoraRTC.onAutoplayFailed = () => {
            console.warn("[WARN] Autoplay è¢«é™åˆ¶ï¼Œåˆ›å»ºæ¢å¤æŒ‰é’®");
            const btn = document.createElement("button");
            btn.innerText = "ç‚¹å‡»æ¢å¤ Bot éŸ³é¢‘";
            btn.style.padding = "12px";
            btn.style.margin = "16px";
            btn.style.background = "#48bb78";
            btn.style.color = "#fff";
            btn.style.borderRadius = "8px";
            btn.onclick = () => {
              if (remoteAudioTrack) {
                remoteAudioTrack.play("remoteAudio");
                console.log("[DEBUG] ç”¨æˆ·ç‚¹å‡»åæ¢å¤æ’­æ”¾æˆåŠŸ");
              }
              btn.remove();
            };
            document.body.appendChild(btn);
          };

          // ?? ä¿®å¤ï¼šåœ¨joinä¹‹å‰æ³¨å†Œäº‹ä»¶ç›‘å¬ï¼Œé¿å…é”™è¿‡Botçš„publishedäº‹ä»¶
          console.log("[DEBUG] åœ¨joinå‰æ³¨å†Œæ‰€æœ‰äº‹ä»¶ç›‘å¬");

          // ç”¨æˆ·åŠ å…¥äº‹ä»¶ - ä½¿ç”¨è®¢é˜…ç®¡ç†å™¨å¤„ç†æ˜¾å¼è®¢é˜…
          client.on("user-joined", async (user) => {
            console.log("[EVENT] user-joined:", user.uid);
            console.log("[EVENT] ç”¨æˆ·åŠ å…¥è¯¦æƒ…:", {
              uid: user.uid,
              hasAudioTrack: !!user.audioTrack,
              hasVideoTrack: !!user.videoTrack,
            });

            // ä½¿ç”¨è®¢é˜…ç®¡ç†å™¨å¤„ç†æ˜¾å¼è®¢é˜…
            if (subscriptionManager && user.hasAudio) {
              const isBot = WebUIDValidator.isBotUser(user.uid);

              try {
                const success = await subscriptionManager.subscribeUser(
                  user,
                  "audio",
                  {
                    onSuccess: (user, mediaType) => {
                      if (isBot) {
                        console.log(
                          "[SUBSCRIBE] ğŸ¤– Botç”¨æˆ·éŸ³é¢‘è®¢é˜…æˆåŠŸï¼Œå‡†å¤‡æ’­æ”¾"
                        );
                        log("Botè¿æ¥", `Botç”¨æˆ· ${user.uid} éŸ³é¢‘æµå·²è®¢é˜…`);
                      }
                    },
                    onError: (user, mediaType, error) => {
                      log(
                        "è®¢é˜…å¤±è´¥",
                        `ç”¨æˆ· ${user.uid} éŸ³é¢‘è®¢é˜…å¤±è´¥: ${error}`
                      );
                    },
                  }
                );

                // å¦‚æœæ˜¯Botç”¨æˆ·ä¸”è®¢é˜…å¤±è´¥ï¼Œå¯åŠ¨è‡ªåŠ¨é‡è¯•
                if (isBot && !success) {
                  console.log(
                    "[SUBSCRIBE] ğŸ”„ Botç”¨æˆ·è®¢é˜…å¤±è´¥ï¼Œå¯åŠ¨è‡ªåŠ¨é‡è¯•æœºåˆ¶"
                  );
                  subscriptionManager.scheduleRetrySubscription(
                    user,
                    "audio",
                    3
                  );
                }
              } catch (error) {
                console.error("[SUBSCRIBE] âŒ è®¢é˜…ç®¡ç†å™¨å¤„ç†å¤±è´¥:", error);
                log("ç³»ç»Ÿé”™è¯¯", `è®¢é˜…ç®¡ç†å™¨å¤„ç†ç”¨æˆ· ${user.uid} å¤±è´¥`);
              }
            } else if (user.hasAudio) {
              // å¦‚æœè®¢é˜…ç®¡ç†å™¨æœªåˆå§‹åŒ–ï¼Œå›é€€åˆ°ç›´æ¥è®¢é˜…
              console.warn("[SUBSCRIBE] âš ï¸ è®¢é˜…ç®¡ç†å™¨æœªåˆå§‹åŒ–ï¼Œä½¿ç”¨ç›´æ¥è®¢é˜…");
              try {
                await client.subscribe(user, "audio");
                console.log("[SUBSCRIBE] âœ… ç›´æ¥è®¢é˜…æˆåŠŸ:", user.uid);
              } catch (error) {
                console.error("[SUBSCRIBE] âŒ ç›´æ¥è®¢é˜…å¤±è´¥:", error);
              }
            } else {
              console.log("[SUBSCRIBE] âš ï¸ ç”¨æˆ·æ— éŸ³é¢‘æµï¼Œè·³è¿‡è®¢é˜…:", user.uid);

              // å¦‚æœæ˜¯Botç”¨æˆ·ä½†æ²¡æœ‰éŸ³é¢‘æµï¼Œè®°å½•è­¦å‘Š
              if (WebUIDValidator.isBotUser(user.uid)) {
                console.warn(
                  "[SUBSCRIBE] âš ï¸ Botç”¨æˆ·æ— éŸ³é¢‘æµï¼Œå¯èƒ½å­˜åœ¨å‘å¸ƒé—®é¢˜"
                );
                log("è­¦å‘Š", `Botç”¨æˆ· ${user.uid} åŠ å…¥ä½†æ— éŸ³é¢‘æµ`);
              }
            }
          });

          // ç”¨æˆ·å‘å¸ƒäº‹ä»¶
          client.on("user-published", handleUserPublished);

          // ç”¨æˆ·å–æ¶ˆå‘å¸ƒäº‹ä»¶
          client.on("user-unpublished", (user, mediaType) => {
            console.log("[EVENT] user-unpublished:", user.uid, mediaType);
            console.log("ç”¨æˆ·å–æ¶ˆå‘å¸ƒ:", user.uid);
            elements.remoteUid.textContent = "-";
            log("å–æ¶ˆå‘å¸ƒ", `UID ${user.uid} å–æ¶ˆå‘å¸ƒéŸ³é¢‘`);
          });

          // å¤„ç†ç”¨æˆ·ç¦»å¼€é¢‘é“
          client.on("user-left", (user) => {
            console.log("[EVENT] user-left:", user.uid);
            console.log("ç”¨æˆ·ç¦»å¼€:", user.uid);
            elements.remoteUid.textContent = "-";
            log("ç¦»å¼€", `UID ${user.uid} å·²ç¦»å¼€`);
          });

          client.on("connection-state-change", (cur, prev, reason) => {
            log("å£°ç½‘", `è¿æ¥çŠ¶æ€: ${prev} -> ${cur} (${reason})`);
          });

          setConnectionState("online", "å£°ç½‘é“¾è·¯å·²å»ºç«‹ï¼Œç­‰å¾… Bot éŸ³é¢‘...");
          elements.disconnectButton.disabled = false;
          log("ç³»ç»Ÿ", "è¿æ¥å®Œæˆï¼ŒBot éŸ³é¢‘å°†è‡ªåŠ¨æ’­æ”¾");

          // ?? æ·»åŠ ï¼šå®šæ—¶æ£€æŸ¥é¢‘é“å†…çš„è¿œç«¯ç”¨æˆ·ï¼ˆå¢å¼ºç‰ˆï¼‰
          setInterval(() => {
            const remoteUsers = client.remoteUsers;
            console.log("[CHECK] =========================");
            console.log("[CHECK] é¢‘é“å†…è¿œç«¯ç”¨æˆ·æ€»æ•°:", remoteUsers.length);

            if (remoteUsers.length === 0) {
              console.log("[CHECK] ?? é¢‘é“å†…æ— è¿œç«¯ç”¨æˆ·");
            } else {
              remoteUsers.forEach((user) => {
                console.log(`[CHECK] ç”¨æˆ· ${user.uid}:`, {
                  hasAudioTrack: !!user.audioTrack,
                  hasVideoTrack: !!user.videoTrack,
                  isPlaying: user.audioTrack?.isPlaying,
                  audioTrackType: typeof user.audioTrack,
                  audioTrackObject: user.audioTrack,
                });

                if (user.audioTrack) {
                  console.log(
                    `[CHECK] ? ç”¨æˆ· ${user.uid} æœ‰éŸ³é¢‘è½¨é“ï¼Œæ’­æ”¾çŠ¶æ€: ${user.audioTrack.isPlaying}`
                  );
                } else {
                  console.log(`[CHECK] ? ç”¨æˆ· ${user.uid} æ— éŸ³é¢‘è½¨é“`);
                }

                // ç‰¹åˆ«æ£€æŸ¥Bot UID - ä½¿ç”¨UIDéªŒè¯å™¨
                if (WebUIDValidator.isBotUser(user.uid)) {
                  console.log(
                    `[CHECK] ğŸ¤– æ£€æµ‹åˆ°Botç”¨æˆ· ${
                      user.uid
                    }! (ç±»å‹: ${typeof user.uid})`
                  );
                  WebUIDValidator.logUIDInfo("Botç”¨æˆ·æ£€æµ‹", user.uid, {
                    hasAudioTrack: !!user.audioTrack,
                    isPlaying: user.audioTrack?.isPlaying,
                  });
                  if (!user.audioTrack) {
                    console.log(
                      `[CHECK] âš ï¸ Botç”¨æˆ·æ— éŸ³é¢‘è½¨é“ï¼Œå¯èƒ½éœ€è¦æ‰‹åŠ¨è®¢é˜…`
                    );
                  }
                }
              });
            }
            console.log("[CHECK] =========================");
          }, 5000); // æ¯5ç§’æ£€æŸ¥ä¸€æ¬¡
        } catch (error) {
          log("é”™è¯¯", `è¿æ¥å¤±è´¥: ${error.message}`, "error");
          await disconnect();
        } finally {
          isConnecting = false;
          if (!elements.disconnectButton.disabled) {
            elements.connectButton.disabled = true;
          } else {
            elements.connectButton.disabled = false;
          }
        }
      }

      async function disconnect() {
        elements.connectButton.disabled = false;
        elements.disconnectButton.disabled = true;
        setConnectionState("offline", "è¿æ¥å·²å…³é—­ï¼Œå¯éšæ—¶é‡æ–°åŠ å…¥é¢‘é“");

        try {
          client.off("user-published", handleUserPublished);
          client.off("user-unpublished", handleUserUnpublished);
          client.off("connection-state-change");

          if (remoteAudioTrack) {
            remoteAudioTrack.stop();
            remoteAudioTrack.close();
            remoteAudioTrack = null;
          }

          if (localTrack) {
            localTrack.stop();
            localTrack.close();
            localTrack = null;
          }

          stopMicMeter();

          // æ¸…ç†è®¢é˜…ç®¡ç†å™¨
          if (subscriptionManager) {
            subscriptionManager.destroy();
            subscriptionManager = null;
            console.log("[SUBSCRIPTION] è®¢é˜…ç®¡ç†å™¨å·²æ¸…ç†");
          }

          if (client.connectionState !== "DISCONNECTED") {
            await client.leave();
          }
          log("ç³»ç»Ÿ", "å·²ç¦»å¼€å£°ç½‘é¢‘é“");
        } catch (error) {
          log("é”™è¯¯", `æ–­å¼€è¿æ¥å‡ºç°é—®é¢˜: ${error.message}`);
        }
      }

      async function handleUserPublished(user, mediaType) {
        console.log(
          "[SUBSCRIBE_FLOW] ?? Detected user publish:",
          user.uid,
          mediaType
        );
        console.log("[DEBUG] user-published:", user.uid, mediaType);
        console.log("[SUBSCRIBE_FLOW] ?? User object before subscribe:", {
          uid: user.uid,
          hasAudioTrack: !!user.audioTrack,
          hasVideoTrack: !!user.videoTrack,
          userObject: user,
        });

        if (mediaType !== "audio") {
          console.log("[DEBUG] ééŸ³é¢‘è½¨é“ï¼Œå¿½ç•¥");
          return;
        }

        try {
          console.log("[SUBSCRIBE_FLOW] ?? å¼€å§‹è®¢é˜…ç”¨æˆ·éŸ³é¢‘:", user.uid);
          console.log(
            '[SUBSCRIBE_FLOW] ?? è°ƒç”¨ client.subscribe(user, "audio")...'
          );

          await client.subscribe(user, "audio");

          console.log("[SUBSCRIBE_FLOW] ? subscribe() è°ƒç”¨å®Œæˆï¼Œæ£€æŸ¥ç»“æœ...");
          console.log("[SUBSCRIBE_FLOW] ?? User object after subscribe:", {
            uid: user.uid,
            hasAudioTrack: !!user.audioTrack,
            audioTrackType: typeof user.audioTrack,
            audioTrackObject: user.audioTrack,
          });

          if (!user.audioTrack) {
            console.error("[SUBSCRIBE_FLOW] ? è®¢é˜…å audioTrack ä»ä¸ºç©ºï¼");
            log("é”™è¯¯", `è®¢é˜… ${user.uid} å audioTrack ä¸ºç©º`);
            return;
          }

          console.log(
            "[SUBSCRIBE_FLOW] ? è®¢é˜…æˆåŠŸï¼Œè·å¾— audioTrack:",
            user.uid
          );
          remoteAudioTrack = user.audioTrack;

          // å°è¯•ç›´æ¥æ’­æ”¾
          try {
            console.log("[SUBSCRIBE_FLOW] ?? å°è¯•æ’­æ”¾åˆ° remoteAudio å…ƒç´ ...");
            remoteAudioTrack.play("remoteAudio");
            console.log("[SUBSCRIBE_FLOW] ? play() è°ƒç”¨æˆåŠŸ");
          } catch (err) {
            console.warn(
              "[SUBSCRIBE_FLOW] ?? play() è°ƒç”¨å¤±è´¥ï¼Œå¯èƒ½è¢« autoplay é™åˆ¶:",
              err
            );
          }

          // è®¾ç½®éŸ³é‡
          const volume = Number(elements.volumeSlider.value);
          remoteAudioTrack.setVolume(volume);
          console.log("[SUBSCRIBE_FLOW] ?? è®¾ç½®éŸ³é‡:", volume);

          // æ‰“å°ç”¨æˆ· UID
          elements.remoteUid.textContent = user.uid || "-";
          log("Bot", `UID ${user.uid} éŸ³é¢‘å·²æ¥å…¥`);

          // å‘¨æœŸæ€§æ‰“å°éŸ³é¢‘ç»Ÿè®¡æ•°æ®
          if (remoteAudioTrack.getStats) {
            setInterval(() => {
              const stats = remoteAudioTrack.getStats();
              console.log("[AUDIO_STATS]", {
                uid: user.uid,
                bitrate: stats?.receiveBitrate,
                packets: stats?.receivePackets,
                lossRate: stats?.receivePacketsLost,
                codec: stats?.codecType,
                isPlaying: remoteAudioTrack?.isPlaying,
              });
            }, 3000);
          }
        } catch (error) {
          console.error("[SUBSCRIBE_FLOW] ? è®¢é˜…è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯:", error);
          console.error("[SUBSCRIBE_FLOW] ?? é”™è¯¯è¯¦æƒ…:", {
            message: error.message,
            code: error.code,
            stack: error.stack,
          });
          log("é”™è¯¯", `æ— æ³•è®¢é˜… Bot éŸ³é¢‘: ${error.message}`);
        }
      }

      function handleUserUnpublished(user, mediaType) {
        if (mediaType === "audio" && remoteAudioTrack) {
          remoteAudioTrack.stop();
          remoteAudioTrack.close();
          remoteAudioTrack = null;
          elements.remoteUid.textContent = "-";
          log("Bot", `UID ${user.uid} å·²ç¦»å¼€é¢‘é“`);
        }
      }

      elements.connectButton.addEventListener("click", connect);
      elements.disconnectButton.addEventListener("click", disconnect);

      elements.volumeSlider.addEventListener("input", (event) => {
        const volume = Number(event.target.value || "70");
        elements.remoteVolume.textContent = `${volume}%`;
        if (remoteAudioTrack) {
          remoteAudioTrack.setVolume(volume);
        }
      });

      window.addEventListener("beforeunload", () => {
        if (client.connectionState !== "DISCONNECTED") {
          client.leave();
        }
      });

      log("ç³»ç»Ÿ", "é¡µé¢åŠ è½½å®Œæˆï¼Œç‚¹å‡»æŒ‰é’®å³å¯ä½“éªŒå£°ç½‘ RTC é“¾è·¯ã€‚");
    </script>
  </body>
</html>
