<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ğŸ¤– åè¯ˆAIåŒå·¥å¯¹è¯å®¢æˆ·ç«¯</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        display: flex;
        justify-content: center;
        align-items: center;
        color: #333;
      }

      .container {
        background: rgba(255, 255, 255, 0.95);
        border-radius: 20px;
        padding: 30px;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        max-width: 800px;
        width: 90%;
        backdrop-filter: blur(10px);
      }

      .header {
        text-align: center;
        margin-bottom: 30px;
      }

      .header h1 {
        color: #4a5568;
        margin-bottom: 10px;
        font-size: 2.2em;
      }

      .header p {
        color: #718096;
        font-size: 1.1em;
      }

      .status-card {
        background: linear-gradient(135deg, #f7fafc 0%, #edf2f7 100%);
        border-radius: 15px;
        padding: 20px;
        margin-bottom: 25px;
        border: 1px solid #e2e8f0;
      }

      .connection-info {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 15px;
        margin-bottom: 20px;
        font-size: 0.9em;
      }

      .connection-info div {
        padding: 10px;
        background: rgba(255, 255, 255, 0.7);
        border-radius: 8px;
        border: 1px solid #e2e8f0;
      }

      .connection-info strong {
        color: #2d3748;
        display: block;
        margin-bottom: 5px;
      }

      .status-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        gap: 15px;
        margin-bottom: 20px;
      }

      .status-item {
        text-align: center;
        padding: 15px;
        background: rgba(255, 255, 255, 0.8);
        border-radius: 10px;
        border: 1px solid #e2e8f0;
      }

      .status-label {
        font-size: 0.85em;
        color: #718096;
        margin-bottom: 5px;
        font-weight: 500;
      }

      .status-value {
        font-size: 1.1em;
        font-weight: bold;
        color: #2d3748;
      }

      .status-value.success {
        color: #38a169;
      }

      .status-value.warning {
        color: #d69e2e;
      }

      .status-value.error {
        color: #e53e3e;
      }

      .controls {
        display: flex;
        justify-content: center;
        gap: 15px;
        margin-bottom: 25px;
        flex-wrap: wrap;
      }

      .btn {
        padding: 12px 24px;
        border: none;
        border-radius: 25px;
        font-size: 1em;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s ease;
        min-width: 120px;
        position: relative;
        overflow: hidden;
      }

      .btn:before {
        content: "";
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(
          90deg,
          transparent,
          rgba(255, 255, 255, 0.2),
          transparent
        );
        transition: left 0.5s;
      }

      .btn:hover:before {
        left: 100%;
      }

      .btn-primary {
        background: linear-gradient(135deg, #4299e1 0%, #3182ce 100%);
        color: white;
        box-shadow: 0 4px 15px rgba(66, 153, 225, 0.3);
      }

      .btn-primary:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(66, 153, 225, 0.4);
      }

      .btn-secondary {
        background: linear-gradient(135deg, #ed8936 0%, #dd6b20 100%);
        color: white;
        box-shadow: 0 4px 15px rgba(237, 137, 54, 0.3);
      }

      .btn-secondary:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(237, 137, 54, 0.4);
      }

      .btn:disabled {
        opacity: 0.6;
        cursor: not-allowed;
        transform: none !important;
      }

      .audio-visualizer {
        background: linear-gradient(135deg, #1a202c 0%, #2d3748 100%);
        border-radius: 15px;
        padding: 20px;
        margin-bottom: 25px;
        text-align: center;
      }

      .audio-visualizer h3 {
        color: #e2e8f0;
        margin-bottom: 15px;
        font-size: 1.1em;
      }

      #audioCanvas {
        width: 100%;
        height: 120px;
        border-radius: 10px;
        background: #000;
        margin-bottom: 10px;
      }

      .audio-level {
        color: #4299e1;
        font-size: 1.2em;
        font-weight: bold;
      }

      .log-container {
        background: #1a202c;
        border-radius: 15px;
        padding: 20px;
        max-height: 300px;
        overflow-y: auto;
      }

      .log-container h3 {
        color: #e2e8f0;
        margin-bottom: 15px;
        font-size: 1.1em;
      }

      .log-entry {
        margin-bottom: 8px;
        padding: 8px 12px;
        border-radius: 6px;
        font-family: "Consolas", "Monaco", monospace;
        font-size: 0.85em;
        line-height: 1.4;
      }

      .log-entry.info {
        background: rgba(66, 153, 225, 0.1);
        color: #90cdf4;
        border-left: 3px solid #4299e1;
      }

      .log-entry.success {
        background: rgba(56, 161, 105, 0.1);
        color: #9ae6b4;
        border-left: 3px solid #38a169;
      }

      .log-entry.warning {
        background: rgba(214, 158, 46, 0.1);
        color: #faf089;
        border-left: 3px solid #d69e2e;
      }

      .log-entry.error {
        background: rgba(229, 62, 62, 0.1);
        color: #feb2b2;
        border-left: 3px solid #e53e3e;
      }

      .timestamp {
        opacity: 0.7;
        font-size: 0.8em;
      }

      /* å“åº”å¼è®¾è®¡ */
      @media (max-width: 768px) {
        .container {
          padding: 20px;
          margin: 10px;
        }

        .connection-info {
          grid-template-columns: 1fr;
        }

        .status-grid {
          grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
        }

        .controls {
          flex-direction: column;
          align-items: center;
        }

        .btn {
          width: 100%;
          max-width: 250px;
        }
      }

      /* åŠ¨ç”»æ•ˆæœ */
      @keyframes pulse {
        0% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.05);
        }
        100% {
          transform: scale(1);
        }
      }

      .recording {
        animation: pulse 1.5s infinite;
      }

      /* æ»šåŠ¨æ¡æ ·å¼ */
      .log-container::-webkit-scrollbar {
        width: 6px;
      }

      .log-container::-webkit-scrollbar-track {
        background: #2d3748;
        border-radius: 3px;
      }

      .log-container::-webkit-scrollbar-thumb {
        background: #4a5568;
        border-radius: 3px;
      }

      .log-container::-webkit-scrollbar-thumb:hover {
        background: #718096;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1>ğŸ¤– åè¯ˆAIåŒå·¥å¯¹è¯ç³»ç»Ÿ</h1>
        <p>åŸºäºWebSocketçš„å®æ—¶è¯­éŸ³äº¤äº’å¹³å°</p>
      </div>

      <div class="status-card">
        <div class="connection-info">
          <div>
            <strong>WebSocketæœåŠ¡:</strong>
            <span id="websocketAddress">wss://cityuantifraud.com/ws</span>
          </div>
          <div>
            <strong>WebSocket:</strong>
            <span id="wsAddress">wss://cityuantifraud.com/ws</span>
          </div>
          <div>
            <strong>è¿æ¥çŠ¶æ€:</strong> <span id="connectionStatus">æœªè¿æ¥</span>
          </div>
          <div>
            <strong>ç³»ç»ŸçŠ¶æ€:</strong> <span id="systemStatus">å¾…æœºä¸­</span>
          </div>
        </div>

        <div class="status-grid">
          <div class="status-item">
            <div class="status-label">éŸ³é¢‘çŠ¶æ€</div>
            <div class="status-value" id="audioStatus">æœªæ¿€æ´»</div>
          </div>
          <div class="status-item">
            <div class="status-label">AIçŠ¶æ€</div>
            <div class="status-value" id="aiStatus">å¾…æœº</div>
          </div>
          <div class="status-item">
            <div class="status-label">å»¶è¿Ÿ</div>
            <div class="status-value" id="latency">-- ms</div>
          </div>
        </div>
      </div>

      <div class="controls">
        <button class="btn btn-primary" id="connectBtn">ğŸ”— å¼€å§‹å¯¹è¯</button>
        <button class="btn btn-secondary" id="disconnectBtn" disabled>
          ğŸ”Œ æ–­å¼€è¿æ¥
        </button>
        <div
          id="appleAudioHint"
          style="
            display: none;
            margin-top: 15px;
            padding: 10px;
            background: rgba(255, 193, 7, 0.1);
            border: 1px solid #ffc107;
            border-radius: 8px;
            color: #856404;
            text-align: center;
          "
        >
          ğŸ è‹¹æœè®¾å¤‡ç”¨æˆ·ï¼šè¯·ç‚¹å‡»æ­¤å¤„æ¿€æ´»éŸ³é¢‘æ’­æ”¾æƒé™
        </div>
      </div>

      <div class="audio-visualizer">
        <h3>ğŸµ éŸ³é¢‘å¯è§†åŒ–</h3>
        <canvas id="audioCanvas"></canvas>
        <div class="audio-level">éŸ³é¢‘ç”µå¹³: <span id="audioLevel">0%</span></div>
      </div>

      <div class="log-container">
        <h3>ğŸ“‹ ç³»ç»Ÿæ—¥å¿—</h3>
        <div id="logOutput"></div>
      </div>
    </div>

    <script>
      // å…¨å±€å˜é‡
      let websocket = null;
      let localStream = null;
      let audioContext = null;
      let analyser = null;

      // è‹¹æœè®¾å¤‡æ£€æµ‹å’ŒéŸ³é¢‘æƒé™ç®¡ç†
      const isAppleDevice = () => {
        return /iPad|iPhone|iPod|Macintosh|Mac OS X/.test(navigator.userAgent);
      };

      // éŸ³é¢‘æƒé™é¢„è·å–æ ‡å¿—
      let audioPermissionGranted = false;
      let audioContextInitialized = false;

      // WebSocketé‡è¿ç›¸å…³å˜é‡
      let websocketReconnecting = false;
      let reconnectAttempts = 0;
      let maxReconnectAttempts = 5;
      let reconnectDelay = 1000; // åˆå§‹é‡è¿å»¶è¿Ÿ1ç§’
      let dataArray = null;
      let animationId = null;

      // æœåŠ¡å™¨é…ç½® - é¦™æ¸¯HTTPSç‰ˆæœ¬
      const WS_URL = "wss://cityuantifraud.com/ws";

      // DOMå…ƒç´ 
      const elements = {
        connectBtn: document.getElementById("connectBtn"),
        disconnectBtn: document.getElementById("disconnectBtn"),

        audioStatus: document.getElementById("audioStatus"),
        aiStatus: document.getElementById("aiStatus"),
        latency: document.getElementById("latency"),
        connectionStatus: document.getElementById("connectionStatus"),
        systemStatus: document.getElementById("systemStatus"),
        logOutput: document.getElementById("logOutput"),
        audioCanvas: document.getElementById("audioCanvas"),
        audioLevel: document.getElementById("audioLevel"),
      };

      // ç»Ÿè®¡æ•°æ®
      const stats = {
        startTime: null,
        messagesReceived: 0,
        messagesSent: 0,
        audioChunksSent: 0,
        errors: 0,
      };

      // è¿æ¥çŠ¶æ€æšä¸¾ - ç®€åŒ–ä¸ºåªæ”¯æŒWebSocket
      const ConnectionState = {
        DISCONNECTED: "disconnected",
        CONNECTING: "connecting",
        CONNECTED: "connected",
        FAILED: "failed",
      };

      // è¿æ¥ç®¡ç†å™¨ç±» - ç®€åŒ–ä¸ºåªæ”¯æŒWebSocket
      class ConnectionManager {
        constructor() {
          this.state = ConnectionState.DISCONNECTED;
          this.mode = "websocket";
          this.audioSender = null;
          this.audioReceiver = null;
        }

        async connect() {
          try {
            log("ğŸš€ å¼€å§‹è¿æ¥WebSocketéŸ³é¢‘æœåŠ¡...");
            elements.connectBtn.disabled = true;
            elements.systemStatus.textContent = "è¿æ¥ä¸­...";

            // è‹¹æœè®¾å¤‡ç‰¹æ®Šå¤„ç†
            if (isAppleDevice()) {
              log("ğŸ æ£€æµ‹åˆ°è‹¹æœè®¾å¤‡ï¼Œæ‰§è¡Œç‰¹æ®ŠéŸ³é¢‘æƒé™å¤„ç†...", "warning");

              // æ£€æŸ¥HTTPS
              if (
                location.protocol !== "https:" &&
                location.hostname !== "localhost"
              ) {
                throw new Error(
                  "è‹¹æœè®¾å¤‡éœ€è¦HTTPSæ‰èƒ½æ­£å¸¸ä½¿ç”¨éŸ³é¢‘åŠŸèƒ½ï¼Œè¯·ä½¿ç”¨HTTPSè®¿é—®"
                );
              }

              // æ˜¾ç¤ºæƒé™è¯·æ±‚æç¤º
              log("ğŸ”” è‹¹æœè®¾å¤‡éœ€è¦éŸ³é¢‘æ’­æ”¾æƒé™ï¼Œæ­£åœ¨è¯·æ±‚...", "info");

              // é¢„è·å–éŸ³é¢‘æ’­æ”¾æƒé™
              await this.initAppleAudioPermissions();

              // é¢å¤–çš„æƒé™ç¡®è®¤
              log(
                "âœ… éŸ³é¢‘æƒé™é¢„è·å–å®Œæˆï¼Œå¦‚æ’­æ”¾æ—¶ä»æœ‰é—®é¢˜è¯·ç‚¹å‡»é¡µé¢ä»»æ„ä½ç½®",
                "success"
              );
            }

            // æ£€æŸ¥æµè§ˆå™¨å…¼å®¹æ€§
            if (
              !navigator.mediaDevices ||
              !navigator.mediaDevices.getUserMedia
            ) {
              throw new Error("æµè§ˆå™¨ä¸æ”¯æŒéŸ³é¢‘å½•åˆ¶");
            }

            // åˆå§‹åŒ–WebSocketè¿æ¥
            await this.initWebSocket();

            // è·å–ç”¨æˆ·åª’ä½“
            await this.initUserMedia();

            // å¯åŠ¨WebSocketéŸ³é¢‘æ¨¡å¼
            log("ğŸ¯ å¯åŠ¨WebSocketéŸ³é¢‘æ¨¡å¼", "success");
            await this.startWebSocketMode();
          } catch (error) {
            log(`è¿æ¥å¤±è´¥: ${error.message}`, "error");
            this.handleConnectionError(error);
          }
        }

        async startWebSocketMode() {
          try {
            this.state = ConnectionState.CONNECTING;

            log("ğŸ”„ å¯åŠ¨WebSocketéŸ³é¢‘æ¨¡å¼ï¼ˆPCMä¸Šè¡Œ + MP3ä¸‹è¡Œï¼‰");

            // åˆå§‹åŒ–éŸ³é¢‘å‘é€å™¨å’Œæ¥æ”¶å™¨
            this.audioSender = new AudioSender(websocket);
            this.audioReceiver = new AudioReceiver(websocket);

            // ğŸ†• åˆå§‹åŒ–å…¨å±€Audioå¯¹è±¡ï¼ˆåœ¨ç”¨æˆ·æ‰‹åŠ¿ä¸­ï¼‰
            await this.audioReceiver.initGlobalAudio();

            // å¼€å§‹éŸ³é¢‘å½•åˆ¶å’Œå‘é€
            await this.audioSender.startRecording(localStream);

            this.state = ConnectionState.CONNECTED;

            elements.systemStatus.textContent = "WebSocketå·²è¿æ¥";
            elements.aiStatus.textContent = "åœ¨çº¿";
            elements.aiStatus.className = "status-value success";
            elements.disconnectBtn.disabled = false;

            // è¯¦ç»†çš„éŸ³é¢‘å¤„ç†è·¯å¾„æ—¥å¿—
            log("âœ… WebSocketéŸ³é¢‘æ¨¡å¼å¯åŠ¨æˆåŠŸ", "success");
            log(
              "ğŸ¤ éŸ³é¢‘ä¸Šè¡Œ: PCM 16kHz â†’ WebSocket â†’ åç«¯AudioProcessor",
              "info"
            );
            log(
              "ğŸ”Š éŸ³é¢‘ä¸‹è¡Œ: TTS MP3 â†’ Base64 â†’ WebSocket â†’ å‰ç«¯Audioæ’­æ”¾",
              "info"
            );
            log("ğŸ›¡ï¸ æ‰“æ–­æœºåˆ¶: VADæ£€æµ‹ â†’ é˜Ÿåˆ—æ¸…ç©º â†’ éŸ³é¢‘åœæ­¢", "info");
            stats.startTime = Date.now();
          } catch (error) {
            this.state = ConnectionState.FAILED;
            log(`WebSocketéŸ³é¢‘æ¨¡å¼å¯åŠ¨å¤±è´¥: ${error.message}`, "error");
            throw error;
          }
        }

        async initWebSocket() {
          // å¤ç”¨ç°æœ‰çš„WebSocketåˆå§‹åŒ–é€»è¾‘
          return initWebSocket();
        }

        async initUserMedia() {
          // å¤ç”¨ç°æœ‰çš„ç”¨æˆ·åª’ä½“è·å–é€»è¾‘
          log("è¯·æ±‚éº¦å…‹é£æƒé™...");
          localStream = await navigator.mediaDevices.getUserMedia({
            audio: {
              echoCancellation: true,
              noiseSuppression: true,
              autoGainControl: true,
              sampleRate: 16000,
            },
            video: false,
          });

          log("âœ… éº¦å…‹é£æƒé™è·å–æˆåŠŸ");
          elements.audioStatus.textContent = "å·²æ¿€æ´»";
          elements.audioStatus.className = "status-value success";

          // åˆå§‹åŒ–éŸ³é¢‘å¯è§†åŒ–ï¼ˆå¤ç”¨ç°æœ‰é€»è¾‘ï¼‰
          initAudioVisualization();
        }

        async initAppleAudioPermissions() {
          try {
            log("ğŸ”§ åˆå§‹åŒ–è‹¹æœè®¾å¤‡éŸ³é¢‘æƒé™...");

            // æ–¹æ³•1: åˆ›å»ºAudioContextå¹¶æ¿€æ´»
            if (!audioContextInitialized) {
              const AudioContextClass =
                window.AudioContext || window.webkitAudioContext;
              if (!audioContext) {
                audioContext = new AudioContextClass();
              }

              // æ¢å¤AudioContextï¼ˆè‹¹æœè®¾å¤‡éœ€è¦ç”¨æˆ·æ‰‹åŠ¿è§¦å‘ï¼‰
              if (audioContext.state === "suspended") {
                await audioContext.resume();
                log("âœ… AudioContextå·²æ¿€æ´»");
              }

              // æ’­æ”¾ä¸€ä¸ªé™éŸ³éŸ³é¢‘æ¥è·å–æ’­æ”¾æƒé™
              const buffer = audioContext.createBuffer(1, 1, 22050);
              const source = audioContext.createBufferSource();
              source.buffer = buffer;
              source.connect(audioContext.destination);
              source.start();

              audioContextInitialized = true;
            }

            // æ–¹æ³•2: åˆ›å»ºå¹¶æ’­æ”¾ä¸€ä¸ªçœŸå®çš„Audioå…ƒç´ ï¼ˆæ›´å¼ºåŠ›çš„æƒé™è·å–ï¼‰
            const testAudio = new Audio();

            // åˆ›å»ºä¸€ä¸ªæçŸ­çš„é™éŸ³MP3 (Base64ç¼–ç )
            const silentMP3 =
              "data:audio/mpeg;base64,SUQzBAAAAAABEVRYWFgAAAAtAAADY29tbWVudABCaWdTb3VuZEJhbmsuY29tIC8gTGFTb25vdGhlcXVlLm9yZwBURU5DAAAAHQAAAW1wM1BST0R1Y2VkIGJ5IEF1ZGFjaXR5AFRJVDIAAAAOAAABzlNvbWV0aGluZyBFbHNlAFRQRTEAAAARAAABzlRoZSBLaWxsZXJzAFRBTEIAAAAQAAABzkRheSAmIEFnZQBUWUVSAAAAFQAAAdBUaGUgS2lsbGVycwBUQ09OAAAAFQAAAQBUZXN0IENvbW1lbnQAVENPUAAAABUAAAEAVGVzdCBDb21tZW50AFRQT1MAAAASAAABADEAVFJDSwAAABIAAAEAMQA=";

            testAudio.src = silentMP3;
            testAudio.volume = 0.01; // æä½éŸ³é‡
            testAudio.muted = false;

            // å°è¯•æ’­æ”¾æ¥è·å–æƒé™
            try {
              const playPromise = testAudio.play();
              if (playPromise !== undefined) {
                await playPromise;
                log("âœ… éŸ³é¢‘æ’­æ”¾æƒé™è·å–æˆåŠŸ (Audioå…ƒç´ æ–¹æ³•)");
              }
            } catch (audioError) {
              log(`Audioå…ƒç´ æ’­æ”¾å¤±è´¥: ${audioError.message}`, "warning");
              // ç»§ç»­å°è¯•å…¶ä»–æ–¹æ³•
            }

            // æ–¹æ³•3: ä½¿ç”¨Web Audio APIåˆ›å»ºæ›´å¤æ‚çš„éŸ³é¢‘æµ‹è¯•
            if (audioContext) {
              try {
                // åˆ›å»ºä¸€ä¸ªçŸ­æš‚çš„æ­£å¼¦æ³¢
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                // è®¾ç½®æä½éŸ³é‡å’ŒçŸ­æš‚æŒç»­æ—¶é—´
                gainNode.gain.setValueAtTime(0.001, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(
                  0.0001,
                  audioContext.currentTime + 0.1
                );

                oscillator.frequency.setValueAtTime(
                  440,
                  audioContext.currentTime
                );
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.1);

                log("âœ… Web Audio APIæƒé™æµ‹è¯•å®Œæˆ");
              } catch (webAudioError) {
                log(
                  `Web Audio APIæµ‹è¯•å¤±è´¥: ${webAudioError.message}`,
                  "warning"
                );
              }
            }

            audioPermissionGranted = true;
            log("âœ… è‹¹æœè®¾å¤‡éŸ³é¢‘æƒé™é¢„è·å–å®Œæˆ");
          } catch (error) {
            log(`è‹¹æœè®¾å¤‡éŸ³é¢‘æƒé™è·å–å¤±è´¥: ${error.message}`, "error");
            throw new Error("éŸ³é¢‘æƒé™è·å–å¤±è´¥ï¼Œè¯·ç¡®ä¿å…è®¸éŸ³é¢‘æ’­æ”¾æƒé™");
          }
        }

        handleConnectionError(error) {
          elements.connectBtn.disabled = false;
          elements.systemStatus.textContent = "è¿æ¥å¤±è´¥";
          stats.errors++;

          // è‹¹æœè®¾å¤‡ç‰¹æ®Šé”™è¯¯æç¤º
          if (isAppleDevice() && error.message.includes("éŸ³é¢‘")) {
            log(`ğŸ è‹¹æœè®¾å¤‡éŸ³é¢‘é—®é¢˜: ${error.message}`, "error");
            log(
              "ğŸ’¡ å»ºè®®: 1) ç¡®ä¿ä½¿ç”¨HTTPS 2) ç‚¹å‡»é¡µé¢ä»»æ„ä½ç½®åé‡è¯• 3) æ£€æŸ¥SafariéŸ³é¢‘æƒé™",
              "info"
            );
          } else {
            log(`è¿æ¥å¤±è´¥å»ºè®®: è¯·æ£€æŸ¥ç½‘ç»œè¿æ¥æˆ–åˆ·æ–°é¡µé¢é‡è¯•`, "info");
          }
        }

        async switchToWebSocketMode() {
          try {
            log("ğŸ”„ é‡æ–°åˆå§‹åŒ–WebSocketéŸ³é¢‘æ¨¡å¼...", "info");

            // æ¸…ç†æ—§çš„éŸ³é¢‘ç»„ä»¶
            if (this.audioSender) {
              this.audioSender.stop();
              this.audioSender = null;
            }
            if (this.audioReceiver) {
              this.audioReceiver.stop();
              this.audioReceiver = null;
            }

            // è‹¹æœè®¾å¤‡ç‰¹æ®Šå¤„ç†ï¼šé‡ç½®éŸ³é¢‘æƒé™çŠ¶æ€å’ŒAudioContext
            if (isAppleDevice()) {
              audioPermissionGranted = false;
              if (audioContext) {
                audioContext.close();
              }
              // é‡æ–°åˆ›å»ºAudioContexté¿å…çŠ¶æ€æ¼‚ç§»
              const AudioContextClass =
                window.AudioContext || window.webkitAudioContext;
              audioContext = new AudioContextClass({ sampleRate: 16000 });
            }

            // é‡æ–°åˆå§‹åŒ–éŸ³é¢‘ç»„ä»¶
            this.audioSender = new AudioSender(websocket);
            this.audioReceiver = new AudioReceiver(websocket);

            await this.audioReceiver.initGlobalAudio();
            await this.audioSender.startRecording(localStream);

            log("âœ… WebSocketéŸ³é¢‘æ¨¡å¼é‡æ–°åˆå§‹åŒ–å®Œæˆ", "success");
          } catch (error) {
            log(`WebSocketæ¨¡å¼é‡æ–°åˆå§‹åŒ–å¤±è´¥: ${error.message}`, "error");
            throw error;
          }
        }

        async disconnect() {
          try {
            log("æ­£åœ¨æ–­å¼€è¿æ¥...");

            // åœæ­¢éŸ³é¢‘å‘é€å™¨
            if (this.audioSender) {
              this.audioSender.stop();
              this.audioSender = null;
            }

            // åœæ­¢éŸ³é¢‘æ¥æ”¶å™¨
            if (this.audioReceiver) {
              this.audioReceiver.stop();
              this.audioReceiver = null;
            }

            // æ–­å¼€WebSocketè¿æ¥
            await disconnectFromServer();

            this.state = ConnectionState.DISCONNECTED;
          } catch (error) {
            log(`æ–­å¼€è¿æ¥æ—¶å‡ºé”™: ${error.message}`, "error");
          }
        }
      }

      // éŸ³é¢‘å‘é€å™¨ç±» - ç®€åŒ–ä¸ºåªæ”¯æŒWebSocket
      class AudioSender {
        constructor(connection) {
          this.connection = connection;
          this.mediaRecorder = null;
          this.isRecording = false;
          this.sequenceNumber = 0;

          // PCMå½•åˆ¶ç›¸å…³å±æ€§
          this.audioContext = null;
          this.sourceNode = null;
          this.processorNode = null;
          this.isPCMRecording = false;
        }

        async initPCMRecorder(stream) {
          try {
            // æ£€æŸ¥AudioContextæ”¯æŒ
            if (!window.AudioContext && !window.webkitAudioContext) {
              throw new Error("æµè§ˆå™¨ä¸æ”¯æŒAudioContextï¼Œé™çº§åˆ°MediaRecorder");
            }

            // åˆ›å»ºAudioContextï¼ˆ16kHzé‡‡æ ·ç‡ï¼‰
            const AudioContextClass =
              window.AudioContext || window.webkitAudioContext;
            this.audioContext = new AudioContextClass({ sampleRate: 16000 });

            // åˆ›å»ºéŸ³é¢‘æºèŠ‚ç‚¹
            this.sourceNode = this.audioContext.createMediaStreamSource(stream);

            // åˆ›å»ºScriptProcessorèŠ‚ç‚¹ï¼ˆ1024æ ·æœ¬ç¼“å†²åŒºï¼‰
            this.processorNode = this.audioContext.createScriptProcessor(
              1024,
              1,
              1
            );

            // è®¾ç½®éŸ³é¢‘å¤„ç†å›è°ƒ
            this.processorNode.onaudioprocess = (event) => {
              if (this.isPCMRecording) {
                const inputBuffer = event.inputBuffer;
                const pcmData = inputBuffer.getChannelData(0); // Float32Array
                this.sendPCMChunk(pcmData);
              }
            };

            // è¿æ¥éŸ³é¢‘èŠ‚ç‚¹
            this.sourceNode.connect(this.processorNode);
            this.processorNode.connect(this.audioContext.destination);

            // å¼€å§‹PCMå½•åˆ¶
            this.isPCMRecording = true;
            log("âœ… PCMå½•åˆ¶å™¨å¯åŠ¨æˆåŠŸ (16kHzå•å£°é“)", "success");
          } catch (error) {
            log(`PCMå½•åˆ¶å™¨åˆå§‹åŒ–å¤±è´¥: ${error.message}`, "error");
            // é™çº§åˆ°MediaRecorder
            await this.fallbackToMediaRecorder(stream);
          }
        }

        sendPCMChunk(pcmData) {
          try {
            // å‰ç«¯é¢„æ‰“æ–­æœºåˆ¶å·²ç¦ç”¨ - å¿…é¡»ä¾èµ–åç«¯Whisperè½¬å†™ç»“æœåˆ¤æ–­æ‰“æ–­
            // åŸå› ï¼šå‰ç«¯ç®€å•çš„RMSæ£€æµ‹ä¼šç»•è¿‡åç«¯çš„é»‘åå•è¿‡æ»¤ï¼Œå¯¼è‡´è¯¯è§¦å‘
            // ç°åœ¨æ‰€æœ‰æ‰“æ–­å†³ç­–éƒ½ç”±åç«¯çš„AudioProcessor.process_audio_with_interrupt_decision()å¤„ç†

            // const rms = Math.sqrt(
            //   pcmData.reduce((sum, sample) => sum + sample * sample, 0) /
            //     pcmData.length
            // );
            // const isActive = rms > 0.01; // ç®€å•çš„é˜ˆå€¼æ£€æµ‹
            //
            // // å¦‚æœæ£€æµ‹åˆ°éŸ³é¢‘æ´»åŠ¨ä¸”æœ‰éŸ³é¢‘æ­£åœ¨æ’­æ”¾ï¼Œç«‹å³è§¦å‘å‰ç«¯æ‰“æ–­
            // if (
            //   isActive &&
            //   connectionManager.audioReceiver &&
            //   connectionManager.audioReceiver.isPlaying
            // ) {
            //   connectionManager.audioReceiver.clearQueue();
            //   // æ³¨æ„ï¼šåç«¯çš„VADä¼šè¿›è¡Œæ›´ç²¾ç¡®çš„æ‰“æ–­æ£€æµ‹
            // }

            // è½¬æ¢Float32åˆ°Int16ï¼ˆæ ‡å‡†éŸ³é¢‘æ ¼å¼ï¼‰
            const int16Data = new Int16Array(pcmData.length);
            for (let i = 0; i < pcmData.length; i++) {
              // é™åˆ¶èŒƒå›´å¹¶è½¬æ¢ä¸º16ä½æ•´æ•°
              const sample = Math.max(-1, Math.min(1, pcmData[i]));
              int16Data[i] = Math.round(sample * 32767);
            }

            // æ„é€ PCMéŸ³é¢‘æ¶ˆæ¯
            const message = {
              type: "audio_chunk",
              data: {
                data: Array.from(int16Data), // å‘é€Int16æ•°ç»„
                format: "pcm_int16",
                sample_rate: 16000,
                channels: 1,
                sequence: this.sequenceNumber++,
                timestamp: Date.now(),
                client_id: "web_client_" + Date.now(),
              },
            };

            // å‘é€PCMæ•°æ®
            if (
              this.connection &&
              this.connection.readyState === WebSocket.OPEN
            ) {
              this.connection.send(JSON.stringify(message));

              // æ›´æ–°ç»Ÿè®¡
              stats.audioChunksSent++;
              if (stats.audioChunksSent % 50 === 0) {
                log(`ğŸ“¤ å·²å‘é€${stats.audioChunksSent}ä¸ªPCMéŸ³é¢‘å—`, "info");
              }
            }
          } catch (error) {
            log(`PCMæ•°æ®å‘é€å¤±è´¥: ${error.message}`, "error");
            stats.errors++;
          }
        }

        async fallbackToMediaRecorder(stream) {
          log("ğŸ”„ é™çº§åˆ°MediaRecorderæ¨¡å¼", "warning");

          // åŸæœ‰çš„MediaRecorderé€»è¾‘
          const options = {
            mimeType: "audio/webm;codecs=opus",
            audioBitsPerSecond: 16000,
          };

          if (!MediaRecorder.isTypeSupported(options.mimeType)) {
            log("æµè§ˆå™¨ä¸æ”¯æŒWebM Opusæ ¼å¼ï¼Œå°è¯•å…¶ä»–æ ¼å¼", "warning");
            const fallbackOptions = [
              { mimeType: "audio/webm" },
              { mimeType: "audio/ogg;codecs=opus" },
              { mimeType: "audio/mp4" },
            ];

            let selectedOptions = null;
            for (const option of fallbackOptions) {
              if (MediaRecorder.isTypeSupported(option.mimeType)) {
                selectedOptions = option;
                log(`ä½¿ç”¨å›é€€æ ¼å¼: ${option.mimeType}`, "info");
                break;
              }
            }

            this.mediaRecorder = selectedOptions
              ? new MediaRecorder(stream, selectedOptions)
              : new MediaRecorder(stream);
          } else {
            this.mediaRecorder = new MediaRecorder(stream, options);
          }

          this.mediaRecorder.ondataavailable = (event) => {
            if (event.data.size > 0) {
              this.sendAudioChunk(event.data);
            }
          };

          this.mediaRecorder.onerror = (event) => {
            log(`éŸ³é¢‘å½•åˆ¶é”™è¯¯: ${event.error}`, "error");
            stats.errors++;
          };

          this.mediaRecorder.start(100);
        }

        async startRecording(stream) {
          try {
            // ä½¿ç”¨PCMå½•åˆ¶
            await this.initPCMRecorder(stream);
            log("ğŸ¤ PCMå½•åˆ¶å™¨åˆå§‹åŒ–æˆåŠŸ", "success");
            this.isRecording = true;
            log("ğŸ¤ WebSocketéŸ³é¢‘å½•åˆ¶å·²å¯åŠ¨");
          } catch (error) {
            log(`å¯åŠ¨éŸ³é¢‘å½•åˆ¶å¤±è´¥: ${error.message}`, "error");
            stats.errors++;
            throw error;
          }
        }

        async sendAudioChunk(audioBlob) {
          try {
            if (
              this.connection &&
              this.connection.readyState === WebSocket.OPEN
            ) {
              // è½¬æ¢ä¸ºBase64
              const arrayBuffer = await audioBlob.arrayBuffer();
              const base64Data = btoa(
                String.fromCharCode(...new Uint8Array(arrayBuffer))
              );

              const message = {
                type: "audio_chunk",
                data: base64Data,
                timestamp: Date.now(),
                sequence: this.sequenceNumber++,
                client_id: "web_client_" + Date.now(),
                format: "webm/opus", // æ˜ç¡®æ ‡è¯†éŸ³é¢‘æ ¼å¼
                sample_rate: 16000, // æ˜ç¡®æ ‡è¯†é‡‡æ ·ç‡
              };

              this.connection.send(JSON.stringify(message));
              stats.messagesSent++;
            } else if (
              this.connection &&
              this.connection.readyState !== WebSocket.OPEN
            ) {
              log(
                `WebSocketè¿æ¥çŠ¶æ€å¼‚å¸¸: ${this.connection.readyState}`,
                "warning"
              );
            }
          } catch (error) {
            log(`å‘é€éŸ³é¢‘æ•°æ®å¤±è´¥: ${error.message}`, "error");
            stats.errors++;
          }
        }

        stop() {
          // åœæ­¢PCMå½•åˆ¶
          if (this.isPCMRecording) {
            this.isPCMRecording = false;

            // æ–­å¼€éŸ³é¢‘èŠ‚ç‚¹è¿æ¥
            if (this.sourceNode && this.processorNode) {
              this.sourceNode.disconnect();
              this.processorNode.disconnect();
            }

            // å…³é—­AudioContext
            if (this.audioContext && this.audioContext.state !== "closed") {
              this.audioContext.close();
            }

            log("ğŸ›‘ PCMå½•åˆ¶å·²åœæ­¢");
          }

          // åœæ­¢MediaRecorderï¼ˆé™çº§æ¨¡å¼ï¼‰
          if (this.mediaRecorder && this.isRecording) {
            this.mediaRecorder.stop();
            log("ğŸ›‘ MediaRecorderå½•åˆ¶å·²åœæ­¢");
          }

          this.isRecording = false;
        }
      }

      // éŸ³é¢‘æ¥æ”¶å™¨ç±» - ä½¿ç”¨å•ä¸€Audioå¯¹è±¡å¤ç”¨ç­–ç•¥
      class AudioReceiver {
        constructor(connection) {
          this.connection = connection;
          this.audioQueue = [];
          this.isPlaying = false;

          // ğŸ†• å•ä¸€Audioå¯¹è±¡å¤ç”¨ç­–ç•¥
          this.globalAudio = null;
          this.currentAudioUrl = null;

          // ğŸ†• Web Audio APIæ”¯æŒï¼ˆè‹¹æœè®¾å¤‡æ‰“æ–­æœºåˆ¶ï¼‰
          this.currentWebAudioSource = null;
          this.isUsingWebAudio = false;

          this.playbackSequence = 0;
          this.retryCount = 0;
          this.maxRetries = 3;
        }

        // ğŸ†• åˆå§‹åŒ–å…¨å±€Audioå¯¹è±¡
        async initGlobalAudio() {
          if (!this.globalAudio) {
            this.globalAudio = new Audio();

            // è®¾ç½®å…¨å±€äº‹ä»¶ç›‘å¬å™¨
            this.globalAudio.onended = () => {
              this.cleanupCurrentAudio();
              this.retryCount = 0;
              log(`âœ… éŸ³é¢‘æ’­æ”¾å®Œæˆ`);
              // ç»§ç»­æ’­æ”¾ä¸‹ä¸€ä¸ª
              this.playNextAudio();
            };

            this.globalAudio.onerror = (error) => {
              log(`âŒ éŸ³é¢‘æ’­æ”¾é”™è¯¯: ${error.message || error}`, "error");
              this.handleAudioError(error);
            };

            this.globalAudio.onloadstart = () => {
              log(`ğŸµ å¼€å§‹æ’­æ”¾éŸ³é¢‘`, "info");
            };

            this.globalAudio.oncanplay = () => {
              log(`ğŸ“» éŸ³é¢‘å·²å‡†å¤‡å°±ç»ª`);
            };

            // è‹¹æœè®¾å¤‡éœ€è¦åœ¨ç”¨æˆ·æ‰‹åŠ¿ä¸­æ¿€æ´»
            if (isAppleDevice()) {
              await this.activateAppleAudio();
            }

            log("âœ… å…¨å±€Audioå¯¹è±¡åˆå§‹åŒ–å®Œæˆ", "success");
          }
        }

        // ğŸ†• è‹¹æœè®¾å¤‡éŸ³é¢‘æƒé™æ¿€æ´» - ç®€åŒ–ç‰ˆæœ¬
        async activateAppleAudio() {
          try {
            log("ğŸ æ£€æŸ¥è‹¹æœè®¾å¤‡éŸ³é¢‘æƒé™çŠ¶æ€...", "info");

            // å¦‚æœå·²ç»æ¿€æ´»è¿‡ï¼Œç›´æ¥è¿”å›
            if (audioPermissionGranted) {
              log("âœ… è‹¹æœè®¾å¤‡éŸ³é¢‘æƒé™å·²å­˜åœ¨", "success");
              return;
            }

            // ç¡®ä¿AudioContextå¤„äºè¿è¡ŒçŠ¶æ€
            if (!audioContext) {
              const AudioContextClass =
                window.AudioContext || window.webkitAudioContext;
              audioContext = new AudioContextClass();
            }

            if (audioContext.state === "suspended") {
              await audioContext.resume();
              log("âœ… AudioContextå·²æ¿€æ´»");
            }

            // ğŸ¯ ä¸åœ¨è¿™é‡Œæ’­æ”¾ä»»ä½•éŸ³é¢‘ï¼Œåªæ£€æŸ¥AudioContextçŠ¶æ€
            if (audioContext.state === "running") {
              audioPermissionGranted = true;
              log("âœ… è‹¹æœè®¾å¤‡Web Audio APIå·²å‡†å¤‡å°±ç»ª", "success");
            } else {
              log("âš ï¸ AudioContextçŠ¶æ€å¼‚å¸¸ï¼Œå°†åœ¨æ’­æ”¾æ—¶é‡è¯•", "warning");
            }
          } catch (error) {
            log(`è‹¹æœè®¾å¤‡éŸ³é¢‘æƒé™æ£€æŸ¥å¤±è´¥: ${error.message}`, "warning");
            // ä¸æŠ›å‡ºé”™è¯¯ï¼Œè®©è¿æ¥ç»§ç»­è¿›è¡Œ
            log("âš ï¸ å°†åœ¨å®é™…æ’­æ”¾æ—¶é‡è¯•æƒé™è·å–", "info");
          }
        }

        // ğŸ†• è‹¹æœè®¾å¤‡ä¸“ç”¨ï¼šWeb Audio APIæ’­æ”¾MP3
        async playMP3WithWebAudio(mp3Data, audioText) {
          try {
            log(`ğŸ ä½¿ç”¨Web Audio APIæ’­æ”¾: "${audioText}"`, "info");

            // ç¡®ä¿AudioContextå¤„äºè¿è¡ŒçŠ¶æ€
            if (!audioContext) {
              const AudioContextClass =
                window.AudioContext || window.webkitAudioContext;
              audioContext = new AudioContextClass();
            }

            if (audioContext.state === "suspended") {
              await audioContext.resume();
              log("âœ… AudioContextå·²æ¢å¤");
            }

            // è§£ç Base64 MP3æ•°æ®
            const binaryString = atob(mp3Data);
            const bytes = new Uint8Array(binaryString.length);
            for (let i = 0; i < binaryString.length; i++) {
              bytes[i] = binaryString.charCodeAt(i);
            }

            // ä½¿ç”¨Web Audio APIè§£ç MP3
            const audioBuffer = await audioContext.decodeAudioData(
              bytes.buffer
            );

            // ğŸ¯ å…³é”®ï¼šåœæ­¢ä¹‹å‰çš„Web Audioæ’­æ”¾ï¼ˆæ”¯æŒæ‰“æ–­ï¼‰
            if (this.currentWebAudioSource) {
              try {
                this.currentWebAudioSource.stop();
                log("ğŸ›‘ åœæ­¢ä¹‹å‰çš„Web Audioæ’­æ”¾", "info");
              } catch (stopError) {
                // å¿½ç•¥å·²ç»åœæ­¢çš„sourceçš„é”™è¯¯
              }
            }

            // åˆ›å»ºæ–°çš„éŸ³é¢‘æº
            const source = audioContext.createBufferSource();
            source.buffer = audioBuffer;
            source.connect(audioContext.destination);

            // ğŸ¯ ä¿å­˜å½“å‰æ’­æ”¾æºï¼ˆç”¨äºæ‰“æ–­æ§åˆ¶ï¼‰
            this.currentWebAudioSource = source;
            this.isUsingWebAudio = true;

            // è®¾ç½®æ’­æ”¾å®Œæˆå›è°ƒ
            source.onended = () => {
              // åªæœ‰æ­£å¸¸æ’­æ”¾å®Œæˆæ‰ç»§ç»­ä¸‹ä¸€ä¸ªï¼ˆè¢«æ‰“æ–­æ—¶ä¸ä¼šè§¦å‘ï¼‰
              if (this.currentWebAudioSource === source) {
                this.currentWebAudioSource = null;
                this.isUsingWebAudio = false;
                this.retryCount = 0;
                log(`âœ… Web Audio APIæ’­æ”¾å®Œæˆ: "${audioText}"`);
                // ç»§ç»­æ’­æ”¾ä¸‹ä¸€ä¸ªéŸ³é¢‘
                this.playNextAudio();
              }
            };

            // ğŸ¯ åœ¨çœŸæ­£æ’­æ”¾æ—¶æ‰è·å–æƒé™
            source.start();
            log(`âœ… Web Audio APIæ’­æ”¾å¼€å§‹`, "success");

            // æ ‡è®°æƒé™å·²è·å¾—
            audioPermissionGranted = true;
          } catch (error) {
            this.currentWebAudioSource = null;
            this.isUsingWebAudio = false;
            log(`Web Audio APIæ’­æ”¾å¤±è´¥: ${error.message}`, "error");
            throw error;
          }
        }

        // ğŸ†• æ¸…ç†å½“å‰éŸ³é¢‘èµ„æº
        cleanupCurrentAudio() {
          if (this.currentAudioUrl) {
            URL.revokeObjectURL(this.currentAudioUrl);
            this.currentAudioUrl = null;
          }
        }

        // ğŸ†• å¤„ç†éŸ³é¢‘æ’­æ”¾é”™è¯¯
        handleAudioError(error) {
          // è‹¹æœè®¾å¤‡ç‰¹æ®Šé”™è¯¯å¤„ç†
          if (isAppleDevice()) {
            log(`ğŸ è‹¹æœè®¾å¤‡éŸ³é¢‘æ’­æ”¾é”™è¯¯: ${error.message || error}`, "error");

            if (!audioPermissionGranted) {
              log("ğŸ’¡ å¯èƒ½éœ€è¦é‡æ–°è·å–éŸ³é¢‘æƒé™", "warning");
            }
          }

          // ä½¿ç”¨é”™è¯¯ç›‘æ§ç³»ç»Ÿ
          errorMonitor.logError("audio", error, {
            retryCount: this.retryCount,
            queueLength: this.audioQueue.length,
            isAppleDevice: isAppleDevice(),
            audioPermissionGranted: audioPermissionGranted,
            audioContextState: audioContext ? audioContext.state : "none",
          });

          this.cleanupCurrentAudio();
          stats.errors++;

          // é‡è¯•æœºåˆ¶
          if (this.retryCount < this.maxRetries) {
            this.retryCount++;
            log(
              `ğŸ”„ éŸ³é¢‘æ’­æ”¾é‡è¯• (${this.retryCount}/${this.maxRetries})`,
              "warning"
            );

            // å»¶è¿Ÿé‡è¯•
            setTimeout(() => this.playNextAudio(), 500 * this.retryCount);
          } else {
            log("âŒ éŸ³é¢‘æ’­æ”¾é‡è¯•æ¬¡æ•°å·²è¾¾ä¸Šé™", "error");
            this.retryCount = 0;
            // å°è¯•æ’­æ”¾ä¸‹ä¸€ä¸ªéŸ³é¢‘
            setTimeout(() => this.playNextAudio(), 100);
          }
        }

        handleIncomingAudio(audioData, metadata = {}) {
          try {
            // æ£€æŸ¥æ˜¯å¦æœ‰éŸ³é¢‘æ•°æ®
            if (!metadata.has_audio || !audioData) {
              // æ²¡æœ‰éŸ³é¢‘æ•°æ®ï¼Œåªæ˜¾ç¤ºæ–‡æœ¬å›å¤
              if (metadata.text) {
                log(`ğŸ”Š AIæ–‡æœ¬å›å¤: ${metadata.text}`, "success");
              }
              return;
            }

            // æ£€æµ‹éŸ³é¢‘æ ¼å¼
            const audioFormat = metadata.audio_format || "webm";

            // ğŸ” è°ƒè¯•æ—¥å¿—ï¼šæ˜¾ç¤ºæ ¼å¼æ£€æµ‹ç»“æœ
            log(
              `ğŸ” [DEBUG] éŸ³é¢‘æ ¼å¼æ£€æµ‹: metadata.audio_format="${metadata.audio_format}", æœ€ç»ˆæ ¼å¼="${audioFormat}"`,
              "info"
            );

            if (audioFormat === "mp3") {
              // å¤„ç†MP3éŸ³é¢‘ï¼ˆæ–°æ ¼å¼ï¼‰
              log(`âœ… [DEBUG] è°ƒç”¨handleMP3Audioæ–¹æ³•`, "success");
              this.handleMP3Audio(audioData, metadata);
            } else {
              // å¤„ç†WebMéŸ³é¢‘ï¼ˆæ—§æ ¼å¼ï¼Œä¿æŒå…¼å®¹æ€§ï¼‰
              log(`âš ï¸ [DEBUG] è°ƒç”¨handleWebMAudioæ–¹æ³•`, "warning");
              this.handleWebMAudio(audioData, metadata);
            }
          } catch (error) {
            log(`éŸ³é¢‘å¤„ç†å¼‚å¸¸: ${error.message}`, "error");
            stats.errors++;

            // è®°å½•è¯¦ç»†é”™è¯¯ä¿¡æ¯ç”¨äºè°ƒè¯•
            errorMonitor.logError("audio", error, {
              audioFormat: audioFormat,
              hasAudioData: !!audioData,
              metadataKeys: Object.keys(metadata),
              queueLength: this.audioQueue.length,
            });

            // å¦‚æœæœ‰æ–‡æœ¬ä½†éŸ³é¢‘å¤„ç†å¤±è´¥ï¼Œä»ç„¶æ˜¾ç¤ºæ–‡æœ¬å›å¤
            if (metadata.text) {
              log(`ğŸ”Š AIæ–‡æœ¬å›å¤: ${metadata.text}`, "success");
            }
          }
        }

        handleMP3Audio(audioData, metadata) {
          try {
            // éªŒè¯Base64æ•°æ®
            if (!audioData || typeof audioData !== "string") {
              throw new Error("æ— æ•ˆçš„MP3éŸ³é¢‘æ•°æ®");
            }

            // è§£ç Base64 MP3æ•°æ®
            const binaryString = atob(audioData);
            const bytes = new Uint8Array(binaryString.length);
            for (let i = 0; i < binaryString.length; i++) {
              bytes[i] = binaryString.charCodeAt(i);
            }

            // éªŒè¯MP3æ–‡ä»¶å¤´ï¼ˆç®€å•æ£€æŸ¥ï¼‰
            if (
              bytes.length < 3 ||
              !(bytes[0] === 0xff && (bytes[1] & 0xe0) === 0xe0)
            ) {
              log("âš ï¸ MP3æ–‡ä»¶å¤´éªŒè¯å¤±è´¥ï¼Œä½†ä»å°è¯•æ’­æ”¾", "warning");
            }

            // åˆ›å»ºMP3 Blob
            const audioBlob = new Blob([bytes], { type: "audio/mpeg" });

            // åŠ å…¥æ’­æ”¾é˜Ÿåˆ—
            this.audioQueue.push({
              blob: audioBlob,
              text: metadata.text,
              timestamp: metadata.timestamp,
              format: "mp3",
              size: bytes.length,
            });

            log(
              `ğŸ“¥ æ”¶åˆ°MP3éŸ³é¢‘å›å¤: "${metadata.text}" (${bytes.length}å­—èŠ‚)`,
              "success"
            );

            // å¦‚æœæ²¡æœ‰æ­£åœ¨æ’­æ”¾ï¼Œç«‹å³æ’­æ”¾
            if (!this.isPlaying) {
              this.playNextAudio();
            }
          } catch (error) {
            log(`MP3éŸ³é¢‘å¤„ç†å¤±è´¥: ${error.message}`, "error");
            stats.errors++;

            // é™çº§æ˜¾ç¤ºæ–‡æœ¬
            if (metadata.text) {
              log(`ğŸ”Š AIæ–‡æœ¬å›å¤: ${metadata.text}`, "success");
            }
          }
        }

        handleWebMAudio(audioData, metadata) {
          try {
            // è§£ç Base64 WebMæ•°æ®ï¼ˆä¿æŒå‘åå…¼å®¹ï¼‰
            const binaryString = atob(audioData);
            const bytes = new Uint8Array(binaryString.length);
            for (let i = 0; i < binaryString.length; i++) {
              bytes[i] = binaryString.charCodeAt(i);
            }

            // åˆ›å»ºéŸ³é¢‘å¯¹è±¡
            const audioItem = {
              data: bytes,
              metadata: metadata,
              timestamp: Date.now(),
              sequence: this.playbackSequence++,
            };

            // æ·»åŠ åˆ°æ’­æ”¾é˜Ÿåˆ—
            this.audioQueue.push(audioItem);

            // è®°å½•éŸ³é¢‘ä¼ è¾“æ—¥å¿—ï¼ˆæ¯10æ¬¡è®°å½•ä¸€æ¬¡ï¼Œé¿å…æ—¥å¿—è¿‡å¤šï¼‰
            if (this.playbackSequence % 10 === 0) {
              log(`ğŸ“¥ éŸ³é¢‘ä¼ è¾“: WebSocket - æ¥æ”¶ - ${bytes.length}å­—èŠ‚`);
            }

            // å¦‚æœå½“å‰æ²¡æœ‰æ’­æ”¾ï¼Œå¼€å§‹æ’­æ”¾
            if (!this.isPlaying) {
              this.playNextAudio();
            }

            // åªåœ¨æ¯10æ¬¡éŸ³é¢‘å›å¤æ—¶è®°å½•æ—¥å¿—ï¼Œé¿å…æ—¥å¿—è¿‡å¤š
            if (this.playbackSequence % 10 === 0) {
              log("ğŸ”Š æ”¶åˆ°WebSocketéŸ³é¢‘å›å¤ï¼Œå·²åŠ å…¥æ’­æ”¾é˜Ÿåˆ—");
            }
          } catch (error) {
            log(`å¤„ç†éŸ³é¢‘æ•°æ®å¤±è´¥: ${error.message}`, "error");
            stats.errors++;

            // å¦‚æœæ˜¯Base64è§£ç é”™è¯¯ï¼Œä½†æœ‰æ–‡æœ¬å›å¤ï¼Œä»ç„¶æ˜¾ç¤ºæ–‡æœ¬
            if (error.message.includes("atob") && metadata.text) {
              log(`ğŸ”Š AIæ–‡æœ¬å›å¤: ${metadata.text}`, "success");
            }
          }
        }

        // ğŸ”„ é‡æ„ï¼šä½¿ç”¨å…¨å±€Audioå¯¹è±¡çš„æ’­æ”¾é€»è¾‘
        async playNextAudio() {
          if (this.audioQueue.length === 0) {
            this.isPlaying = false;
            return;
          }

          // ç¡®ä¿å…¨å±€Audioå¯¹è±¡å·²åˆå§‹åŒ–
          if (!this.globalAudio) {
            log("âš ï¸ å…¨å±€Audioå¯¹è±¡æœªåˆå§‹åŒ–ï¼Œæ­£åœ¨åˆå§‹åŒ–...", "warning");
            await this.initGlobalAudio();
          }

          this.isPlaying = true;
          const audioItem = this.audioQueue.shift();

          try {
            let audioBlob;
            let formatName;

            // æ ¹æ®éŸ³é¢‘æ ¼å¼åˆ›å»ºæ­£ç¡®çš„Blob
            if (audioItem.format === "mp3") {
              audioBlob = audioItem.blob;
              formatName = "MP3";
            } else {
              audioBlob = new Blob([audioItem.data], { type: "audio/webm" });
              formatName = "WebM";
            }

            // æ¸…ç†ä¹‹å‰çš„éŸ³é¢‘URL
            this.cleanupCurrentAudio();

            // åˆ›å»ºæ–°çš„éŸ³é¢‘URLå¹¶è®¾ç½®åˆ°å…¨å±€Audioå¯¹è±¡
            this.currentAudioUrl = URL.createObjectURL(audioBlob);
            this.globalAudio.src = this.currentAudioUrl;

            // è®¾ç½®éŸ³é¢‘å±æ€§
            this.globalAudio.preload = "auto";
            if (isAppleDevice()) {
              this.globalAudio.crossOrigin = "anonymous";
            }

            // æ›´æ–°æ—¥å¿—ä¿¡æ¯ï¼ˆåŒ…å«æ–‡æœ¬å†…å®¹ï¼‰
            const audioText = audioItem.text || "æ— æ–‡æœ¬";
            log(`ğŸµ å‡†å¤‡æ’­æ”¾${formatName}éŸ³é¢‘: "${audioText}"`, "info");

            // ï¿½ è‹¹æœè®¾è¿›å¤‡ç‰¹æ®Šå¤„ç†ï¼šMP3ä½¿ç”¨Web Audio API
            if (isAppleDevice() && audioItem.format === "mp3") {
              log("ğŸ è‹¹æœè®¾å¤‡ä½¿ç”¨Web Audio APIæ’­æ”¾MP3", "info");

              // ä»Blobè¯»å–Base64æ•°æ®
              const reader = new FileReader();
              reader.onload = async () => {
                try {
                  const base64Data = reader.result.split(",")[1]; // ç§»é™¤data:audio/mpeg;base64,å‰ç¼€
                  await this.playMP3WithWebAudio(base64Data, audioText);
                } catch (webAudioError) {
                  log(
                    `Web Audio APIæ’­æ”¾å¤±è´¥ï¼Œé™çº§åˆ°Audioå…ƒç´ : ${webAudioError.message}`,
                    "warning"
                  );
                  // é™çº§åˆ°Audioå…ƒç´ æ’­æ”¾
                  await this.globalAudio.play();
                }
              };
              reader.readAsDataURL(audioBlob);
              return; // æå‰è¿”å›ï¼Œä¸æ‰§è¡Œä¸‹é¢çš„Audioå…ƒç´ æ’­æ”¾
            }

            // ğŸ–¥ï¸ éè‹¹æœè®¾å¤‡æˆ–WebMæ ¼å¼ï¼šä½¿ç”¨Audioå…ƒç´ æ’­æ”¾
            await this.globalAudio.play();
            log(`âœ… ${formatName}éŸ³é¢‘å¼€å§‹æ’­æ”¾`, "success");
          } catch (error) {
            log(`éŸ³é¢‘æ’­æ”¾å¤±è´¥: ${error.message}`, "error");

            // å¦‚æœæ˜¯æƒé™é—®é¢˜ä¸”æ˜¯è‹¹æœè®¾å¤‡
            if (
              isAppleDevice() &&
              (error.name === "NotAllowedError" ||
                error.message.includes("not supported"))
            ) {
              log("ğŸ è‹¹æœè®¾å¤‡æƒé™é—®é¢˜ï¼Œå°è¯•é‡æ–°æ¿€æ´»...", "warning");

              try {
                // é‡æ–°æ¿€æ´»éŸ³é¢‘æƒé™
                await this.activateAppleAudio();
                // å°†å½“å‰éŸ³é¢‘é‡æ–°åŠ å…¥é˜Ÿåˆ—å¤´éƒ¨
                this.audioQueue.unshift(audioItem);
                // é‡è¯•æ’­æ”¾
                setTimeout(() => this.playNextAudio(), 100);
                return;
              } catch (activateError) {
                log(`æƒé™é‡æ–°æ¿€æ´»å¤±è´¥: ${activateError.message}`, "error");
              }
            }

            // ä½¿ç”¨ç»Ÿä¸€çš„é”™è¯¯å¤„ç†
            this.handleAudioError(error);
          }
        }

        // æ¸…ç©ºæ’­æ”¾é˜Ÿåˆ—ï¼ˆç”¨äºæ‰“æ–­ï¼‰- æ”¯æŒWeb Audio API
        clearQueue() {
          const queueLength = this.audioQueue.length;
          const wasPlaying = this.isPlaying;

          // ğŸ¯ åœæ­¢Web Audio APIæ’­æ”¾ï¼ˆè‹¹æœè®¾å¤‡ï¼‰
          if (this.currentWebAudioSource) {
            try {
              this.currentWebAudioSource.stop();
              log("ğŸ›‘ åœæ­¢Web Audio APIæ’­æ”¾", "info");
            } catch (stopError) {
              // å¿½ç•¥å·²ç»åœæ­¢çš„sourceçš„é”™è¯¯
            }
            this.currentWebAudioSource = null;
            this.isUsingWebAudio = false;
          }

          // ğŸ¯ åœæ­¢Audioå…ƒç´ æ’­æ”¾ï¼ˆå…¶ä»–è®¾å¤‡ï¼‰
          if (this.globalAudio) {
            this.globalAudio.pause();
            this.globalAudio.currentTime = 0;
          }

          // æ¸…ç†éŸ³é¢‘èµ„æº
          this.cleanupCurrentAudio();

          // æ¸…ç©ºé˜Ÿåˆ—
          this.audioQueue = [];
          this.isPlaying = false;

          if (queueLength > 0 || wasPlaying) {
            log(
              `ğŸ›‘ éŸ³é¢‘æ’­æ”¾å·²æ‰“æ–­ï¼Œæ¸…ç©ºé˜Ÿåˆ— (${queueLength}ä¸ªå¾…æ’­æ”¾é¡¹ç›®)`,
              "info"
            );
          }
        }

        // æš‚åœå½“å‰æ’­æ”¾ - æ”¯æŒWeb Audio API
        pause() {
          // ğŸ¯ Web Audio APIæ— æ³•æš‚åœï¼Œåªèƒ½åœæ­¢
          if (this.isUsingWebAudio && this.currentWebAudioSource) {
            try {
              this.currentWebAudioSource.stop();
              log("ğŸ›‘ åœæ­¢Web Audio APIæ’­æ”¾ï¼ˆæ— æ³•æš‚åœï¼‰", "info");
            } catch (stopError) {
              // å¿½ç•¥é”™è¯¯
            }
            this.currentWebAudioSource = null;
            this.isUsingWebAudio = false;
          }

          // ğŸ¯ Audioå…ƒç´ å¯ä»¥æš‚åœ
          if (this.globalAudio) {
            this.globalAudio.pause();
          }

          this.isPlaying = false;
        }

        // æ¢å¤æ’­æ”¾ - Web Audio APIé™åˆ¶è¯´æ˜
        resume() {
          // ğŸ¯ Web Audio APIæ— æ³•æ¢å¤ï¼Œåªèƒ½é‡æ–°æ’­æ”¾ä¸‹ä¸€ä¸ª
          if (this.isUsingWebAudio) {
            log("âš ï¸ Web Audio APIæ— æ³•æ¢å¤æ’­æ”¾ï¼Œå°†æ’­æ”¾ä¸‹ä¸€ä¸ªéŸ³é¢‘", "warning");
            this.playNextAudio();
            return;
          }

          // ğŸ¯ Audioå…ƒç´ å¯ä»¥æ¢å¤
          if (this.globalAudio && this.globalAudio.paused) {
            this.globalAudio.play().catch((error) => {
              log(`æ¢å¤æ’­æ”¾å¤±è´¥: ${error.message}`, "error");
            });
            this.isPlaying = true;
          }
        }

        // ğŸ†• åœæ­¢æ’­æ”¾å¹¶æ¸…ç†èµ„æº - æ”¯æŒWeb Audio API
        stop() {
          // ğŸ¯ åœæ­¢Web Audio API
          if (this.currentWebAudioSource) {
            try {
              this.currentWebAudioSource.stop();
            } catch (stopError) {
              // å¿½ç•¥é”™è¯¯
            }
            this.currentWebAudioSource = null;
            this.isUsingWebAudio = false;
          }

          // ğŸ¯ åœæ­¢Audioå…ƒç´ 
          if (this.globalAudio) {
            this.globalAudio.pause();
            this.globalAudio.currentTime = 0;
            // ç§»é™¤äº‹ä»¶ç›‘å¬å™¨
            this.globalAudio.onended = null;
            this.globalAudio.onerror = null;
            this.globalAudio.onloadstart = null;
            this.globalAudio.oncanplay = null;
          }

          this.cleanupCurrentAudio();
          this.clearQueue();
          this.globalAudio = null;
          log("ğŸ›‘ AudioReceiverå·²åœæ­¢", "info");
        }

        // å¤„ç†éŸ³é¢‘æ§åˆ¶æŒ‡ä»¤
        handleAudioControl(message) {
          try {
            const action = message.action;

            switch (action) {
              case "stop":
                // æ”¶åˆ°åœæ­¢æŒ‡ä»¤ï¼Œç«‹å³æ¸…ç©ºé˜Ÿåˆ—å’Œåœæ­¢æ’­æ”¾
                this.clearQueue();
                log("ğŸ›‘ æ”¶åˆ°åç«¯åœæ­¢æŒ‡ä»¤ï¼ŒéŸ³é¢‘æ’­æ”¾å·²ä¸­æ–­", "info");
                break;
              case "pause":
                // æš‚åœå½“å‰æ’­æ”¾
                this.pause();
                log("â¸ï¸ æ”¶åˆ°æš‚åœæŒ‡ä»¤", "info");
                break;
              case "resume":
                // æ¢å¤æ’­æ”¾
                this.resume();
                log("â–¶ï¸ æ”¶åˆ°æ¢å¤æ’­æ”¾æŒ‡ä»¤", "info");
                break;
              default:
                log(`âš ï¸ æœªçŸ¥çš„éŸ³é¢‘æ§åˆ¶æŒ‡ä»¤: ${action}`, "warning");
            }
          } catch (error) {
            log(`éŸ³é¢‘æ§åˆ¶å¤„ç†å¤±è´¥: ${error.message}`, "error");
          }
        }

        stop() {
          this.clearQueue();
          this.playbackSequence = 0;
        }
      }

      // é”™è¯¯ç›‘æ§å’Œæ—¥å¿—æ¨¡å— - ç®€åŒ–ä¸ºåªæ”¯æŒWebSocket
      class ErrorMonitor {
        constructor() {
          this.errorCounts = {
            websocket: 0,
            audio: 0,
            pcm: 0,
            mp3: 0,
            tts: 0,
          };
          this.errorHistory = [];
          this.maxHistorySize = 100;
        }

        logError(category, error, context = {}) {
          const errorEntry = {
            timestamp: Date.now(),
            category: category,
            message: error.message || error,
            context: context,
            stack: error.stack || null,
          };

          this.errorHistory.push(errorEntry);
          if (this.errorHistory.length > this.maxHistorySize) {
            this.errorHistory.shift();
          }

          this.errorCounts[category] = (this.errorCounts[category] || 0) + 1;

          // è¯¦ç»†é”™è¯¯æ—¥å¿—
          log(`âŒ [${category.toUpperCase()}] ${errorEntry.message}`, "error");

          // å¦‚æœæœ‰ä¸Šä¸‹æ–‡ä¿¡æ¯ï¼Œä¹Ÿè®°å½•
          if (Object.keys(context).length > 0) {
            log(`ğŸ“‹ é”™è¯¯ä¸Šä¸‹æ–‡: ${JSON.stringify(context)}`, "info");
          }
        }

        getErrorSummary() {
          return {
            counts: this.errorCounts,
            recentErrors: this.errorHistory.slice(-10),
            totalErrors: this.errorHistory.length,
          };
        }

        clearHistory() {
          this.errorHistory = [];
          this.errorCounts = {
            websocket: 0,
            audio: 0,
            pcm: 0,
            mp3: 0,
            tts: 0,
          };
          log("ğŸ§¹ é”™è¯¯å†å²å·²æ¸…ç©º", "info");
        }
      }

      // å…¨å±€é”™è¯¯ç›‘æ§å®ä¾‹
      const errorMonitor = new ErrorMonitor();

      // å…¨å±€è¿æ¥ç®¡ç†å™¨å®ä¾‹
      let connectionManager = new ConnectionManager();

      // äº‹ä»¶ç›‘å¬å™¨
      elements.connectBtn.addEventListener("click", () =>
        connectionManager.connect()
      );
      elements.disconnectBtn.addEventListener("click", () =>
        connectionManager.disconnect()
      );

      // æ—¥å¿—å‡½æ•°
      function log(message, type = "info") {
        const timestamp = new Date().toLocaleTimeString();
        const logEntry = document.createElement("div");
        logEntry.className = `log-entry ${type}`;
        logEntry.innerHTML = `
          <span class="timestamp">[${timestamp}]</span> ${message}
        `;
        elements.logOutput.appendChild(logEntry);
        elements.logOutput.scrollTop = elements.logOutput.scrollHeight;
        console.log(`[${type.toUpperCase()}] ${message}`);
      }

      // WebSocketè‡ªåŠ¨é‡è¿è°ƒåº¦
      function scheduleWebSocketReconnect() {
        if (websocketReconnecting) return;

        websocketReconnecting = true;
        reconnectAttempts++;

        if (reconnectAttempts > maxReconnectAttempts) {
          log(
            `âŒ WebSocketé‡è¿å¤±è´¥ï¼Œå·²è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•° (${maxReconnectAttempts})`,
            "error"
          );
          websocketReconnecting = false;
          reconnectAttempts = 0;

          // æ˜¾ç¤ºé‡è¿å¤±è´¥æç¤º
          elements.connectionStatus.textContent = "WebSocketé‡è¿å¤±è´¥";
          elements.systemStatus.textContent = "è¿æ¥å¼‚å¸¸";
          return;
        }

        const delay = Math.min(
          reconnectDelay * Math.pow(2, reconnectAttempts - 1),
          30000
        ); // æœ€å¤§30ç§’
        log(
          `ğŸ”„ WebSocketå°†åœ¨ ${
            delay / 1000
          } ç§’åé‡è¿ (ç¬¬${reconnectAttempts}æ¬¡å°è¯•)`,
          "warning"
        );

        setTimeout(async () => {
          try {
            log(
              `ğŸ”„ å¼€å§‹WebSocketé‡è¿å°è¯• ${reconnectAttempts}/${maxReconnectAttempts}...`
            );
            await initWebSocket();

            // é‡è¿æˆåŠŸï¼Œé‡ç½®è®¡æ•°å™¨
            reconnectAttempts = 0;
            websocketReconnecting = false;
            log("âœ… WebSocketé‡è¿æˆåŠŸ", "success");

            // å¦‚æœæ˜¯WebSocketéŸ³é¢‘æ¨¡å¼ï¼Œé‡æ–°åˆå§‹åŒ–éŸ³é¢‘å¤„ç†
            if (connectionManager.mode === "websocket") {
              await connectionManager.switchToWebSocketMode();
            }
          } catch (error) {
            log(`âŒ WebSocketé‡è¿å¤±è´¥: ${error.message}`, "error");
            websocketReconnecting = false;

            // ç»§ç»­ä¸‹ä¸€æ¬¡é‡è¿å°è¯•
            scheduleWebSocketReconnect();
          }
        }, delay);
      }

      // åˆå§‹åŒ–WebSocketè¿æ¥
      async function initWebSocket() {
        try {
          websocket = new WebSocket(WS_URL);

          websocket.onopen = () => {
            log("WebSocketè¿æ¥å·²å»ºç«‹");
            elements.connectionStatus.textContent = "WebSocketå·²è¿æ¥";

            // å‘é€ç»‘å®šæ¶ˆæ¯ - è‹¹æœè®¾å¤‡å»¶è¿Ÿ50msé¿å…"ä¼ªopen"é—®é¢˜
            const bindMsg = {
              type: "bind",
              client_id: "web_client_" + Date.now(),
              timestamp: Date.now(),
            };
            setTimeout(() => {
              websocket.send(JSON.stringify(bindMsg));
              log("å·²å‘é€WebSocketç»‘å®šæ¶ˆæ¯");
            }, 50);
          };

          websocket.onmessage = (event) => {
            try {
              const message = JSON.parse(event.data);
              handleWebSocketMessage(message);
            } catch (e) {
              log("WebSocketæ¶ˆæ¯è§£æå¤±è´¥: " + e.message, "error");
            }
          };

          websocket.onclose = (event) => {
            log(
              `WebSocketè¿æ¥å·²å…³é—­ (ä»£ç : ${event.code}, åŸå› : ${event.reason})`
            );
            elements.connectionStatus.textContent = "WebSocketå·²æ–­å¼€";

            // è‡ªåŠ¨é‡è¿æœºåˆ¶
            if (
              !websocketReconnecting &&
              connectionManager.mode === "websocket"
            ) {
              scheduleWebSocketReconnect();
            }
          };

          websocket.onerror = (error) => {
            // ä½¿ç”¨é”™è¯¯ç›‘æ§ç³»ç»Ÿ
            errorMonitor.logError("websocket", error, {
              url: WS_URL,
              readyState: websocket ? websocket.readyState : "unknown",
              mode: connectionManager.mode,
            });
            stats.errors++;

            // è‡ªåŠ¨é‡è¿æœºåˆ¶
            if (
              !websocketReconnecting &&
              connectionManager.mode === "websocket"
            ) {
              scheduleWebSocketReconnect();
            }
          };
        } catch (error) {
          log("WebSocketåˆå§‹åŒ–å¤±è´¥: " + error.message, "error");
        }
      }

      // å¤„ç†WebSocketæ¶ˆæ¯
      function handleWebSocketMessage(message) {
        log("æ”¶åˆ°WebSocketæ¶ˆæ¯: " + message.type);
        stats.messagesReceived++;

        switch (message.type) {
          case "bind_confirm":
            log("WebSocketç»‘å®šç¡®è®¤", "success");
            break;
          case "interrupt_signal":
            log("æ”¶åˆ°æ‰“æ–­ä¿¡å·", "warning");
            // ç«‹å³æ¸…ç©ºéŸ³é¢‘æ’­æ”¾é˜Ÿåˆ—
            if (connectionManager.audioReceiver) {
              connectionManager.audioReceiver.clearQueue();
              log("ğŸ›‘ æ ¹æ®åç«¯æ‰“æ–­ä¿¡å·æ¸…ç©ºéŸ³é¢‘é˜Ÿåˆ—", "info");
            }
            break;
          case "audio_response":
            // å¤„ç†WebSocketéŸ³é¢‘å›å¤
            if (connectionManager.audioReceiver) {
              const metadata = {
                text: message.text,
                timestamp: message.timestamp,
                sequence: message.sequence,
                has_audio: message.has_audio || false,
                audio_format: message.audio_format || "webm", // ğŸ”§ ä¿®å¤ï¼šåŒ…å«éŸ³é¢‘æ ¼å¼å­—æ®µ
              };

              // åªæœ‰å½“æœ‰éŸ³é¢‘æ•°æ®æ—¶æ‰ä¼ é€’dataå­—æ®µ
              const audioData = message.has_audio ? message.data : null;

              connectionManager.audioReceiver.handleIncomingAudio(
                audioData,
                metadata
              );
            } else if (message.text) {
              // å¦‚æœæ²¡æœ‰éŸ³é¢‘æ¥æ”¶å™¨ä½†æœ‰æ–‡æœ¬ï¼Œç›´æ¥æ˜¾ç¤ºæ–‡æœ¬
              log(`ğŸ”Š AIå›å¤: ${message.text}`, "success");
            }
            break;
          case "audio_control":
            // å¤„ç†éŸ³é¢‘æ§åˆ¶æŒ‡ä»¤ï¼ˆæ‰“æ–­æœºåˆ¶ï¼‰
            if (connectionManager.audioReceiver) {
              connectionManager.audioReceiver.handleAudioControl(message);
            }
            break;
          // æ³¨æ„ï¼šAIéŸ³é¢‘å›å¤ä½¿ç”¨WebSocketä¼ è¾“æ¨¡å¼
        }
      }

      // è¿æ¥åˆ°æœåŠ¡å™¨ - ç®€åŒ–ä¸ºåªä½¿ç”¨WebSocket
      async function connectToServer() {
        try {
          log("å¼€å§‹è¿æ¥åˆ°WebSocketæœåŠ¡å™¨...");
          elements.connectBtn.disabled = true;
          elements.systemStatus.textContent = "è¿æ¥ä¸­...";

          // æ£€æŸ¥æµè§ˆå™¨å…¼å®¹æ€§
          if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
            throw new Error("æµè§ˆå™¨ä¸æ”¯æŒéŸ³é¢‘å½•åˆ¶");
          }

          // åˆå§‹åŒ–WebSocket
          await initWebSocket();

          // è·å–ç”¨æˆ·åª’ä½“
          log("è¯·æ±‚éº¦å…‹é£æƒé™...");
          localStream = await navigator.mediaDevices.getUserMedia({
            audio: {
              echoCancellation: true,
              noiseSuppression: true,
              autoGainControl: true,
              sampleRate: 16000,
            },
            video: false,
          });

          log("âœ… éº¦å…‹é£æƒé™è·å–æˆåŠŸ");
          elements.audioStatus.textContent = "å·²æ¿€æ´»";
          elements.audioStatus.className = "status-value success";

          // åˆå§‹åŒ–éŸ³é¢‘å¯è§†åŒ–
          initAudioVisualization();

          elements.connectionStatus.textContent = "WebSocketå·²è¿æ¥";

          elements.systemStatus.textContent = "å·²è¿æ¥";
          elements.disconnectBtn.disabled = false;
          log("âœ… WebSocketæœåŠ¡å™¨è¿æ¥æˆåŠŸï¼", "success");
          stats.startTime = Date.now();
        } catch (error) {
          log(`âŒ è¿æ¥å¤±è´¥: ${error.message}`, "error");
          elements.connectBtn.disabled = false;
          elements.systemStatus.textContent = "è¿æ¥å¤±è´¥";
          stats.errors++;
        }
      }

      // æ–­å¼€è¿æ¥ - ç®€åŒ–ä¸ºåªå¤„ç†WebSocket
      async function disconnectFromServer() {
        try {
          log("æ­£åœ¨æ–­å¼€è¿æ¥...");

          // åœæ­¢éŸ³é¢‘å¯è§†åŒ–
          if (animationId) {
            cancelAnimationFrame(animationId);
            animationId = null;
          }

          // åœæ­¢æœ¬åœ°æµ
          if (localStream) {
            localStream.getTracks().forEach((track) => track.stop());
            localStream = null;
          }

          // å…³é—­WebSocket
          if (websocket) {
            websocket.close();
            websocket = null;
          }

          // é‡ç½®UIçŠ¶æ€
          elements.connectBtn.disabled = false;
          elements.disconnectBtn.disabled = true;

          elements.audioStatus.textContent = "æœªæ¿€æ´»";
          elements.audioStatus.className = "status-value";
          elements.connectionStatus.textContent = "WebSocketå·²è¿æ¥";
          elements.systemStatus.textContent = "å·²æ–­å¼€";
          elements.latency.textContent = "-- ms";

          log("âœ… å·²æ–­å¼€è¿æ¥", "success");
        } catch (error) {
          log(`âŒ æ–­å¼€è¿æ¥æ—¶å‡ºé”™: ${error.message}`, "error");
        }
      }

      // åˆå§‹åŒ–éŸ³é¢‘å¯è§†åŒ–
      function initAudioVisualization() {
        try {
          audioContext = new (window.AudioContext ||
            window.webkitAudioContext)();
          analyser = audioContext.createAnalyser();
          analyser.fftSize = 256;

          const source = audioContext.createMediaStreamSource(localStream);
          source.connect(analyser);

          const bufferLength = analyser.frequencyBinCount;
          dataArray = new Uint8Array(bufferLength);

          drawAudioVisualization();
          log("ğŸµ éŸ³é¢‘å¯è§†åŒ–å·²å¯åŠ¨");
        } catch (error) {
          log(`éŸ³é¢‘å¯è§†åŒ–åˆå§‹åŒ–å¤±è´¥: ${error.message}`, "warning");
        }
      }

      // ç»˜åˆ¶éŸ³é¢‘å¯è§†åŒ–
      function drawAudioVisualization() {
        if (!analyser || !dataArray) return;

        animationId = requestAnimationFrame(drawAudioVisualization);

        analyser.getByteFrequencyData(dataArray);

        const canvas = elements.audioCanvas;
        const canvasCtx = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        canvasCtx.clearRect(0, 0, WIDTH, HEIGHT);

        const barWidth = (WIDTH / dataArray.length) * 2.5;
        let barHeight;
        let x = 0;

        let sum = 0;
        for (let i = 0; i < dataArray.length; i++) {
          sum += dataArray[i];
        }
        const average = sum / dataArray.length;
        elements.audioLevel.textContent = Math.round(average) + "%";

        for (let i = 0; i < dataArray.length; i++) {
          barHeight = (dataArray[i] / 255) * canvas.height;

          const gradient = canvasCtx.createLinearGradient(
            0,
            canvas.height - barHeight,
            0,
            canvas.height
          );
          gradient.addColorStop(0, "#4299e1");
          gradient.addColorStop(1, "#3182ce");

          canvasCtx.fillStyle = gradient;
          canvasCtx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);

          x += barWidth + 1;
        }
      }

      // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
      function updateStats() {
        if (stats.startTime) {
          const uptime = Date.now() - stats.startTime;
          // è¿™é‡Œå¯ä»¥æ·»åŠ æ›´å¤šç»Ÿè®¡ä¿¡æ¯çš„æ›´æ–°
        }
        setTimeout(updateStats, 1000);
      }

      // å…¨å±€é”™è¯¯å¤„ç†å™¨
      window.addEventListener("error", (event) => {
        log(`å…¨å±€é”™è¯¯: ${event.error?.message || event.message}`, "error");
        stats.errors++;

        // è®°å½•é”™è¯¯ä¿¡æ¯
        if (event.error) {
          log(`é”™è¯¯å»ºè®®: è¯·æ£€æŸ¥ç½‘ç»œè¿æ¥æˆ–åˆ·æ–°é¡µé¢é‡è¯•`, "info");
        }
      });

      window.addEventListener("unhandledrejection", (event) => {
        log(`æœªå¤„ç†çš„Promiseæ‹’ç»: ${event.reason}`, "error");
        stats.errors++;

        // é˜»æ­¢é»˜è®¤çš„æ§åˆ¶å°é”™è¯¯è¾“å‡º
        event.preventDefault();
      });

      // è‹¹æœè®¾å¤‡éŸ³é¢‘æƒé™é¢„å¤„ç† - ç®€åŒ–ç‰ˆæœ¬
      function setupAppleDeviceAudioSupport() {
        if (isAppleDevice()) {
          log("ğŸ æ£€æµ‹åˆ°è‹¹æœè®¾å¤‡ï¼Œè®¾ç½®éŸ³é¢‘æƒé™ç­–ç•¥...", "info");

          // ç®€å•çš„ç”¨æˆ·äº¤äº’ç›‘å¬å™¨ï¼Œåªæ¿€æ´»AudioContext
          const activateAudioOnInteraction = async (event) => {
            try {
              if (!audioPermissionGranted) {
                log("ğŸ”§ ç”¨æˆ·äº¤äº’è§¦å‘ï¼Œæ¿€æ´»AudioContext...", "info");

                // åªæ¿€æ´»AudioContextï¼Œä¸å°è¯•æ’­æ”¾Audioå…ƒç´ 
                if (!audioContext) {
                  const AudioContextClass =
                    window.AudioContext || window.webkitAudioContext;
                  audioContext = new AudioContextClass();
                }

                if (audioContext.state === "suspended") {
                  await audioContext.resume();
                  log("âœ… AudioContextå·²æ¿€æ´»");
                }

                // æ ‡è®°ä¸ºå·²æ¿€æ´»
                audioPermissionGranted = true;

                // éšè—æç¤º
                const hint = document.getElementById("appleAudioHint");
                if (hint) {
                  hint.style.display = "none";
                }

                // ç§»é™¤ç›‘å¬å™¨
                document.removeEventListener(
                  "click",
                  activateAudioOnInteraction
                );
                document.removeEventListener(
                  "touchstart",
                  activateAudioOnInteraction
                );

                log("âœ… è‹¹æœè®¾å¤‡éŸ³é¢‘ç³»ç»Ÿå·²æ¿€æ´»", "success");
              }
            } catch (error) {
              log(`éŸ³é¢‘ç³»ç»Ÿæ¿€æ´»å¤±è´¥: ${error.message}`, "error");
            }
          };

          // æ˜¾ç¤ºè‹¹æœè®¾å¤‡æç¤º
          const hint = document.getElementById("appleAudioHint");
          if (hint) {
            hint.style.display = "block";
            hint.style.cursor = "pointer";
            hint.onclick = activateAudioOnInteraction;
          }

          // æ·»åŠ äº¤äº’ç›‘å¬å™¨
          document.addEventListener("click", activateAudioOnInteraction);
          document.addEventListener("touchstart", activateAudioOnInteraction);

          log("ğŸ”” è‹¹æœè®¾å¤‡éŸ³é¢‘æ”¯æŒå·²è®¾ç½®ï¼Œè¯·ç‚¹å‡»é¡µé¢æ¿€æ´»éŸ³é¢‘æƒé™", "info");
        }
      }

      // åˆå§‹åŒ–
      document.addEventListener("DOMContentLoaded", () => {
        log("é¡µé¢åŠ è½½å®Œæˆï¼Œåˆå§‹åŒ–ç³»ç»Ÿ...");

        // è®¾ç½®è‹¹æœè®¾å¤‡éŸ³é¢‘æ”¯æŒ
        setupAppleDeviceAudioSupport();

        // åˆå§‹åŒ–WebSocketè¿æ¥
        initWebSocket();
        updateStats();
      });
    </script>
  </body>
</html>
