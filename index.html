<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>声网 RTC 双工对话客户端</title>
    <script src="https://download.agora.io/sdk/release/AgoraRTC_N-4.20.0.js"></script>
    <script src="web_uid_validator.js"></script>
    <script src="web_subscription_manager.js"></script>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(135deg, #5a67d8 0%, #805ad5 100%);
        min-height: 100vh;
        display: flex;
        justify-content: center;
        align-items: center;
        color: #1a202c;
        padding: 24px;
      }

      .container {
        width: 100%;
        max-width: 900px;
        background: rgba(255, 255, 255, 0.96);
        border-radius: 20px;
        padding: 32px;
        box-shadow: 0 20px 60px rgba(67, 56, 202, 0.18);
      }

      header {
        text-align: center;
        margin-bottom: 24px;
      }

      header h1 {
        font-size: 2.2rem;
        color: #2d3748;
        margin-bottom: 8px;
      }

      header p {
        color: #4a5568;
      }

      .status-panel {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        gap: 16px;
        margin-bottom: 24px;
      }

      .status-card {
        background: linear-gradient(135deg, #edf2f7 0%, #e2e8f0 100%);
        border-radius: 14px;
        padding: 18px;
        border: 1px solid #cbd5f5;
      }

      .status-card h2 {
        font-size: 1rem;
        color: #2b6cb0;
        margin-bottom: 8px;
        text-transform: uppercase;
        letter-spacing: 0.06em;
      }

      .status-value {
        font-size: 1.2rem;
        font-weight: 600;
      }

      .status-value.online {
        color: #2f855a;
      }

      .status-value.offline {
        color: #c53030;
      }

      .status-value.idle {
        color: #b7791f;
      }

      .controls {
        display: flex;
        flex-wrap: wrap;
        gap: 16px;
        margin-bottom: 24px;
        justify-content: center;
      }

      button {
        padding: 12px 28px;
        border: none;
        border-radius: 999px;
        font-size: 1rem;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.25s ease;
        color: #fff;
      }

      button.primary {
        background: linear-gradient(135deg, #48bb78, #38a169);
      }

      button.primary:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }

      button.danger {
        background: linear-gradient(135deg, #f56565, #e53e3e);
      }

      button.danger:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }

      .meter {
        background: #edf2f7;
        border-radius: 14px;
        padding: 12px 18px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        font-size: 0.95rem;
        color: #4a5568;
      }

      .meter span {
        font-weight: 600;
        color: #2d3748;
      }

      .meter-bar {
        margin-top: 8px;
        width: 180px;
        height: 10px;
        background: #e2e8f0;
        border-radius: 999px;
        overflow: hidden;
      }

      .meter-fill {
        height: 100%;
        width: 0%;
        background: linear-gradient(135deg, #63b3ed, #3182ce);
        transition: width 0.1s ease;
      }

      .conversation-log {
        background: #f7fafc;
        border-radius: 14px;
        border: 1px solid #e2e8f0;
        padding: 18px;
        max-height: 260px;
        overflow-y: auto;
      }

      .log-entry {
        margin-bottom: 12px;
        padding-bottom: 12px;
        border-bottom: 1px dashed rgba(160, 174, 192, 0.5);
      }

      .log-entry:last-child {
        border-bottom: none;
      }

      .log-entry time {
        display: block;
        font-size: 0.8rem;
        color: #718096;
        margin-bottom: 4px;
      }

      .log-entry strong {
        display: inline-block;
        min-width: 70px;
        color: #2b6cb0;
      }

      .volume-control {
        display: flex;
        align-items: center;
        gap: 12px;
        justify-content: center;
        margin-top: 8px;
      }

      .volume-control label {
        font-weight: 600;
        color: #2d3748;
      }

      .volume-control input {
        width: 220px;
      }

      footer {
        margin-top: 24px;
        text-align: center;
        font-size: 0.85rem;
        color: #4a5568;
      }

      footer code {
        background: #edf2f7;
        padding: 2px 6px;
        border-radius: 6px;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <header>
        <h1>声网 RTC 双工对话客户端</h1>
        <p>浏览器直接加入声网频道，上行麦克风、下行 Bot 音频</p>
      </header>

      <section class="status-panel">
        <div class="status-card">
          <h2>连接状态</h2>
          <div id="connectionStatus" class="status-value offline">未连接</div>
          <p id="statusHint">点击开始对话即可连接声网</p>
        </div>
        <div class="status-card">
          <h2>频道信息</h2>
          <div class="status-value">
            <div>频道：<span id="channelName">-</span></div>
            <div>本地 UID：<span id="localUid">-</span></div>
          </div>
        </div>
        <div class="status-card">
          <h2>Bot 状态</h2>
          <div class="status-value">
            <div>远端 UID：<span id="remoteUid">-</span></div>
            <div>音量：<span id="remoteVolume">70%</span></div>
          </div>
        </div>
      </section>

      <section class="controls">
        <button id="connectButton" class="primary">开始对话</button>
        <button id="disconnectButton" class="danger" disabled>断开连接</button>
      </section>

      <section class="meter">
        <div>
          <span>麦克风电平</span>
          <div class="meter-bar">
            <div id="micBar" class="meter-fill"></div>
          </div>
        </div>
        <div>
          <span id="micLevel">0%</span>
        </div>
      </section>

      <div class="volume-control">
        <label for="volumeSlider">Bot 音量</label>
        <input id="volumeSlider" type="range" min="0" max="100" value="70" />
      </div>

      <section class="conversation-log" id="logContainer"></section>

      <div id="remoteAudio"></div>

      <footer>
        <div>
          调试命令：<code
            >curl https://cityuantifraud.com/api/agora/config</code
          >
        </div>
      </footer>
    </div>

    <script>
      const client = AgoraRTC.createClient({ mode: "rtc", codec: "vp8" });
      let localTrack = null;
      let remoteAudioTrack = null;
      let agoraConfigCache = null;
      const backendBaseUrl = "https://cityuantifraud.com";
      let isConnecting = false;
      let subscriptionManager = null;
      let audioContext = null;
      let analyser = null;
      let micDataArray = null;
      let meterAnimation = null;

      const elements = {
        connectionStatus: document.getElementById("connectionStatus"),
        statusHint: document.getElementById("statusHint"),
        channelName: document.getElementById("channelName"),
        localUid: document.getElementById("localUid"),
        remoteUid: document.getElementById("remoteUid"),
        remoteVolume: document.getElementById("remoteVolume"),
        connectButton: document.getElementById("connectButton"),
        disconnectButton: document.getElementById("disconnectButton"),
        volumeSlider: document.getElementById("volumeSlider"),
        micLevel: document.getElementById("micLevel"),
        micBar: document.getElementById("micBar"),
        logContainer: document.getElementById("logContainer"),
      };

      function log(source, message, type = "info") {
        const entry = document.createElement("div");
        entry.className = "log-entry";
        const timestamp = new Date().toLocaleTimeString();
        entry.innerHTML = `
          <time>${timestamp}</time>
          <div><strong>${source}</strong>${message}</div>
        `;
        if (type === "error") {
          entry.style.color = "#c53030";
        } else if (type === "success") {
          entry.style.color = "#2f855a";
        }
        elements.logContainer.appendChild(entry);
        elements.logContainer.scrollTop = elements.logContainer.scrollHeight;
      }

      function setConnectionState(state, hint) {
        elements.connectionStatus.classList.remove("online", "offline", "idle");
        elements.connectionStatus.classList.add(state);
        elements.connectionStatus.textContent =
          state === "online"
            ? "已连接"
            : state === "offline"
            ? "未连接"
            : "准备中";
        if (hint) {
          elements.statusHint.textContent = hint;
        }
      }

      async function fetchAgoraConfig(role = "publisher") {
        if (role === "publisher" && agoraConfigCache) {
          return agoraConfigCache;
        }
        const url = new URL("/api/agora/config", backendBaseUrl);
        url.searchParams.set("role", role);
        const response = await fetch(url.toString(), {
          method: "GET",
          headers: { "Content-Type": "application/json" },
        });
        if (!response.ok) {
          throw new Error(`后端接口返回 ${response.status}`);
        }
        const config = await response.json();
        if (!config || !config.appId) {
          throw new Error("后端缺少声网 App ID");
        }

        // UID配置验证
        const validationResult = WebUIDValidator.validateConfiguration(config);
        if (!validationResult.isValid) {
          console.error("[CONFIG] UID配置验证失败:", validationResult.errors);
          throw new Error(`UID配置无效: ${validationResult.errors.join(", ")}`);
        }

        if (validationResult.warnings.length > 0) {
          console.warn("[CONFIG] UID配置警告:", validationResult.warnings);
        }

        // 记录UID信息
        WebUIDValidator.logUIDInfo("配置验证", config.botUid, {
          userUID: config.uid,
          channel: config.channel,
        });

        if (role === "publisher") {
          agoraConfigCache = config;
        }
        return config;
      }

      function startMicMeter(track) {
        try {
          const streamTrack = track.getMediaStreamTrack();
          if (!streamTrack) {
            return;
          }
          audioContext = new (window.AudioContext ||
            window.webkitAudioContext)();
          const source = audioContext.createMediaStreamSource(
            new MediaStream([streamTrack])
          );
          analyser = audioContext.createAnalyser();
          analyser.fftSize = 256;
          const bufferLength = analyser.frequencyBinCount;
          micDataArray = new Uint8Array(bufferLength);
          source.connect(analyser);

          const update = () => {
            analyser.getByteTimeDomainData(micDataArray);
            let sum = 0;
            for (let i = 0; i < micDataArray.length; i += 1) {
              const value = micDataArray[i] - 128;
              sum += value * value;
            }
            const rms = Math.sqrt(sum / micDataArray.length);
            const level = Math.min(
              100,
              Math.max(0, Math.round((rms / 128) * 100))
            );
            elements.micLevel.textContent = `${level}%`;
            if (elements.micBar) {
              elements.micBar.style.width = `${level}%`;
            }
            meterAnimation = requestAnimationFrame(update);
          };
          update();
        } catch (error) {
          log("系统", `麦克风电平监控异常: ${error.message}`);
        }
      }

      function stopMicMeter() {
        if (meterAnimation) {
          cancelAnimationFrame(meterAnimation);
          meterAnimation = null;
        }
        if (audioContext) {
          audioContext.close();
          audioContext = null;
        }
        analyser = null;
        micDataArray = null;
        elements.micLevel.textContent = "0%";
        if (elements.micBar) {
          elements.micBar.style.width = "0%";
        }
      }

      async function connect() {
        if (isConnecting) {
          return;
        }
        isConnecting = true;
        setConnectionState("idle", "正在初始化声网通道...");
        elements.connectButton.disabled = true;
        log("系统", "准备连接声网 RTC...");

        try {
          const config = await fetchAgoraConfig("publisher");
          console.log("[DEBUG] 获取到的Agora配置:", {
            appId: config.appId,
            channel: config.channel,
            uid: config.uid,
            botUid: config.botUid,
            token: config.token
              ? `${config.token.substring(0, 20)}...`
              : "null",
          });
          elements.localUid.textContent = config.uid || "-";
          elements.channelName.textContent = config.channel || "-";

          if (client.connectionState !== "DISCONNECTED") {
            await client.leave().catch(() => {});
          }

          await client.join(
            config.appId,
            config.channel,
            config.token || null,
            config.uid || null
          );
          log("声网", `已加入频道 ${config.channel}`);

          // 初始化订阅管理器 - 声网技术支持建议：显式订阅确保兼容性
          subscriptionManager = new WebSubscriptionManager(client, {
            maxRetryAttempts: 3,
            retryDelay: 2000,
            enableAutoSubscribe: true,
            logLevel: "info",
          });

          // 设置订阅管理器回调
          subscriptionManager.onSubscriptionSuccess = (
            uid,
            mediaType,
            result
          ) => {
            console.log(`[SUBSCRIPTION] ✅ 订阅成功: ${uid} (${mediaType})`);
            log(
              "订阅",
              `成功订阅用户 ${uid} 的${
                mediaType === "audio" ? "音频" : "视频"
              }流`
            );

            // 特别处理Bot用户的音频订阅
            if (WebUIDValidator.isBotUser(uid) && mediaType === "audio") {
              console.log(`[SUBSCRIPTION] 🤖 Bot用户音频订阅成功，开始播放`);
              if (result && result.play) {
                result.play();
              }
            }
          };

          subscriptionManager.onSubscriptionFailed = (
            uid,
            mediaType,
            error
          ) => {
            console.error(
              `[SUBSCRIPTION] ❌ 订阅失败: ${uid} (${mediaType})`,
              error
            );
            log(
              "订阅",
              `订阅用户 ${uid} 的${
                mediaType === "audio" ? "音频" : "视频"
              }流失败: ${error.message}`,
              "error"
            );
          };

          subscriptionManager.onSubscriptionStateChanged = (
            uid,
            mediaType,
            state
          ) => {
            console.log(
              `[SUBSCRIPTION] 🔄 订阅状态变化: ${uid} (${mediaType}) -> ${state}`
            );

            // 更新UI显示
            if (WebUIDValidator.isBotUser(uid) && mediaType === "audio") {
              const stateText =
                {
                  not_subscribed: "未订阅",
                  subscribing: "订阅中",
                  subscribed: "已订阅",
                  subscription_failed: "订阅失败",
                  unsubscribing: "取消订阅中",
                }[state] || state;

              elements.remoteUid.textContent = `Bot(${uid}) - ${stateText}`;
            }
          };

          console.log("[SUBSCRIPTION] 订阅管理器初始化完成，已设置回调函数");

          // [DEBUG] 检查当前远端用户
          console.log("[DEBUG] 当前远端用户:", client.remoteUsers);
          console.log("[DEBUG] 远端用户数量:", client.remoteUsers.length);
          client.remoteUsers.forEach((user) => {
            console.log("[DEBUG] 远端用户详情:", {
              uid: user.uid,
              hasAudio: user.hasAudio,
              hasVideo: user.hasVideo,
            });
          });

          // [AUDIO_FLOW] 检查麦克风权限和设备
          try {
            const devices = await AgoraRTC.getDevices();
            const audioInputs = devices.filter(
              (device) => device.kind === "audioinput"
            );
            console.log(
              "[AUDIO_FLOW] 可用音频输入设备:",
              audioInputs.map((d) => ({ id: d.deviceId, label: d.label }))
            );

            if (audioInputs.length === 0) {
              console.warn("[AUDIO_FLOW] 警告: 未检测到音频输入设备");
            }
          } catch (error) {
            console.error("[AUDIO_FLOW] 获取音频设备失败:", error);
          }

          console.log("[AUDIO_FLOW] 开始创建麦克风音频轨道...");
          localTrack = await AgoraRTC.createMicrophoneAudioTrack({
            encoderConfig: {
              sampleRate: 48000,
              stereo: false,
            },
          });

          // [AUDIO_FLOW] 音频轨道创建成功调试日志
          console.log("[AUDIO_FLOW] 麦克风音频轨道已创建:", {
            trackId: localTrack.getTrackId(),
            enabled: localTrack.enabled,
            muted: localTrack.muted,
            sampleRate: 48000,
          });

          await client.publish(localTrack);

          // [AUDIO_FLOW] 音频发布成功调试日志
          console.log("[AUDIO_FLOW] 本地音频已发布到声网:", {
            trackId: localTrack.getTrackId(),
            published: true,
            clientState: client.connectionState,
          });

          log("声网", "本地音频已发布");

          // [AUDIO_FLOW] 添加音频数据处理器监听音频流
          let audioFrameCounter = 0;
          try {
            const processor = {
              process: (audioBuffer) => {
                audioFrameCounter++;
                if (audioFrameCounter % 100 === 0) {
                  console.log(
                    "[AUDIO_FLOW] 音频数据流经声网SDK (第" +
                      audioFrameCounter +
                      "帧):",
                    {
                      sampleRate: audioBuffer.sampleRate,
                      numberOfChannels: audioBuffer.numberOfChannels,
                      length: audioBuffer.length,
                      timestamp: Date.now(),
                    }
                  );
                }
                return audioBuffer;
              },
            };

            if (localTrack.pipe && typeof localTrack.pipe === "function") {
              localTrack.pipe(processor);
              console.log("[AUDIO_FLOW] 音频处理器已添加到本地轨道");
            } else {
              console.log(
                "[AUDIO_FLOW] 本地轨道不支持pipe方法，尝试其他监听方式"
              );
            }
          } catch (error) {
            console.log("[AUDIO_FLOW] 添加音频处理器失败:", error.message);
          }

          startMicMeter(localTrack);

          // 处理 Autoplay 限制
          AgoraRTC.onAutoplayFailed = () => {
            console.warn("[WARN] Autoplay 被限制，创建恢复按钮");
            const btn = document.createElement("button");
            btn.innerText = "点击恢复 Bot 音频";
            btn.style.padding = "12px";
            btn.style.margin = "16px";
            btn.style.background = "#48bb78";
            btn.style.color = "#fff";
            btn.style.borderRadius = "8px";
            btn.onclick = () => {
              if (remoteAudioTrack) {
                remoteAudioTrack.play("remoteAudio");
                console.log("[DEBUG] 用户点击后恢复播放成功");
              }
              btn.remove();
            };
            document.body.appendChild(btn);
          };

          // ?? 修复：在join之前注册事件监听，避免错过Bot的published事件
          console.log("[DEBUG] 在join前注册所有事件监听");

          // 用户加入事件 - 使用订阅管理器处理显式订阅
          client.on("user-joined", async (user) => {
            console.log("[EVENT] user-joined:", user.uid);
            console.log("[EVENT] 用户加入详情:", {
              uid: user.uid,
              hasAudioTrack: !!user.audioTrack,
              hasVideoTrack: !!user.videoTrack,
            });

            // 使用订阅管理器处理显式订阅
            if (subscriptionManager && user.hasAudio) {
              const isBot = WebUIDValidator.isBotUser(user.uid);

              try {
                const success = await subscriptionManager.subscribeUser(
                  user,
                  "audio",
                  {
                    onSuccess: (user, mediaType) => {
                      if (isBot) {
                        console.log(
                          "[SUBSCRIBE] 🤖 Bot用户音频订阅成功，准备播放"
                        );
                        log("Bot连接", `Bot用户 ${user.uid} 音频流已订阅`);
                      }
                    },
                    onError: (user, mediaType, error) => {
                      log(
                        "订阅失败",
                        `用户 ${user.uid} 音频订阅失败: ${error}`
                      );
                    },
                  }
                );

                // 如果是Bot用户且订阅失败，启动自动重试
                if (isBot && !success) {
                  console.log(
                    "[SUBSCRIBE] 🔄 Bot用户订阅失败，启动自动重试机制"
                  );
                  subscriptionManager.scheduleRetrySubscription(
                    user,
                    "audio",
                    3
                  );
                }
              } catch (error) {
                console.error("[SUBSCRIBE] ❌ 订阅管理器处理失败:", error);
                log("系统错误", `订阅管理器处理用户 ${user.uid} 失败`);
              }
            } else if (user.hasAudio) {
              // 如果订阅管理器未初始化，回退到直接订阅
              console.warn("[SUBSCRIBE] ⚠️ 订阅管理器未初始化，使用直接订阅");
              try {
                await client.subscribe(user, "audio");
                console.log("[SUBSCRIBE] ✅ 直接订阅成功:", user.uid);
              } catch (error) {
                console.error("[SUBSCRIBE] ❌ 直接订阅失败:", error);
              }
            } else {
              console.log("[SUBSCRIBE] ⚠️ 用户无音频流，跳过订阅:", user.uid);

              // 如果是Bot用户但没有音频流，记录警告
              if (WebUIDValidator.isBotUser(user.uid)) {
                console.warn(
                  "[SUBSCRIBE] ⚠️ Bot用户无音频流，可能存在发布问题"
                );
                log("警告", `Bot用户 ${user.uid} 加入但无音频流`);
              }
            }
          });

          // 用户发布事件
          client.on("user-published", handleUserPublished);

          // 用户取消发布事件
          client.on("user-unpublished", (user, mediaType) => {
            console.log("[EVENT] user-unpublished:", user.uid, mediaType);
            console.log("用户取消发布:", user.uid);
            elements.remoteUid.textContent = "-";
            log("取消发布", `UID ${user.uid} 取消发布音频`);
          });

          // 处理用户离开频道
          client.on("user-left", (user) => {
            console.log("[EVENT] user-left:", user.uid);
            console.log("用户离开:", user.uid);
            elements.remoteUid.textContent = "-";
            log("离开", `UID ${user.uid} 已离开`);
          });

          client.on("connection-state-change", (cur, prev, reason) => {
            log("声网", `连接状态: ${prev} -> ${cur} (${reason})`);
          });

          setConnectionState("online", "声网链路已建立，等待 Bot 音频...");
          elements.disconnectButton.disabled = false;
          log("系统", "连接完成，Bot 音频将自动播放");

          // ?? 添加：定时检查频道内的远端用户（增强版）
          setInterval(() => {
            const remoteUsers = client.remoteUsers;
            console.log("[CHECK] =========================");
            console.log("[CHECK] 频道内远端用户总数:", remoteUsers.length);

            if (remoteUsers.length === 0) {
              console.log("[CHECK] ?? 频道内无远端用户");
            } else {
              remoteUsers.forEach((user) => {
                console.log(`[CHECK] 用户 ${user.uid}:`, {
                  hasAudioTrack: !!user.audioTrack,
                  hasVideoTrack: !!user.videoTrack,
                  isPlaying: user.audioTrack?.isPlaying,
                  audioTrackType: typeof user.audioTrack,
                  audioTrackObject: user.audioTrack,
                });

                if (user.audioTrack) {
                  console.log(
                    `[CHECK] ? 用户 ${user.uid} 有音频轨道，播放状态: ${user.audioTrack.isPlaying}`
                  );
                } else {
                  console.log(`[CHECK] ? 用户 ${user.uid} 无音频轨道`);
                }

                // 特别检查Bot UID - 使用UID验证器
                if (WebUIDValidator.isBotUser(user.uid)) {
                  console.log(
                    `[CHECK] 🤖 检测到Bot用户 ${
                      user.uid
                    }! (类型: ${typeof user.uid})`
                  );
                  WebUIDValidator.logUIDInfo("Bot用户检测", user.uid, {
                    hasAudioTrack: !!user.audioTrack,
                    isPlaying: user.audioTrack?.isPlaying,
                  });
                  if (!user.audioTrack) {
                    console.log(
                      `[CHECK] ⚠️ Bot用户无音频轨道，可能需要手动订阅`
                    );
                  }
                }
              });
            }
            console.log("[CHECK] =========================");
          }, 5000); // 每5秒检查一次
        } catch (error) {
          log("错误", `连接失败: ${error.message}`, "error");
          await disconnect();
        } finally {
          isConnecting = false;
          if (!elements.disconnectButton.disabled) {
            elements.connectButton.disabled = true;
          } else {
            elements.connectButton.disabled = false;
          }
        }
      }

      async function disconnect() {
        elements.connectButton.disabled = false;
        elements.disconnectButton.disabled = true;
        setConnectionState("offline", "连接已关闭，可随时重新加入频道");

        try {
          client.off("user-published", handleUserPublished);
          client.off("user-unpublished", handleUserUnpublished);
          client.off("connection-state-change");

          if (remoteAudioTrack) {
            remoteAudioTrack.stop();
            remoteAudioTrack.close();
            remoteAudioTrack = null;
          }

          if (localTrack) {
            localTrack.stop();
            localTrack.close();
            localTrack = null;
          }

          stopMicMeter();

          // 清理订阅管理器
          if (subscriptionManager) {
            subscriptionManager.destroy();
            subscriptionManager = null;
            console.log("[SUBSCRIPTION] 订阅管理器已清理");
          }

          if (client.connectionState !== "DISCONNECTED") {
            await client.leave();
          }
          log("系统", "已离开声网频道");
        } catch (error) {
          log("错误", `断开连接出现问题: ${error.message}`);
        }
      }

      async function handleUserPublished(user, mediaType) {
        console.log(
          "[SUBSCRIBE_FLOW] ?? Detected user publish:",
          user.uid,
          mediaType
        );
        console.log("[DEBUG] user-published:", user.uid, mediaType);
        console.log("[SUBSCRIBE_FLOW] ?? User object before subscribe:", {
          uid: user.uid,
          hasAudioTrack: !!user.audioTrack,
          hasVideoTrack: !!user.videoTrack,
          userObject: user,
        });

        if (mediaType !== "audio") {
          console.log("[DEBUG] 非音频轨道，忽略");
          return;
        }

        try {
          console.log("[SUBSCRIBE_FLOW] ?? 开始订阅用户音频:", user.uid);
          console.log(
            '[SUBSCRIBE_FLOW] ?? 调用 client.subscribe(user, "audio")...'
          );

          await client.subscribe(user, "audio");

          console.log("[SUBSCRIBE_FLOW] ? subscribe() 调用完成，检查结果...");
          console.log("[SUBSCRIBE_FLOW] ?? User object after subscribe:", {
            uid: user.uid,
            hasAudioTrack: !!user.audioTrack,
            audioTrackType: typeof user.audioTrack,
            audioTrackObject: user.audioTrack,
          });

          if (!user.audioTrack) {
            console.error("[SUBSCRIBE_FLOW] ? 订阅后 audioTrack 仍为空！");
            log("错误", `订阅 ${user.uid} 后 audioTrack 为空`);
            return;
          }

          console.log(
            "[SUBSCRIBE_FLOW] ? 订阅成功，获得 audioTrack:",
            user.uid
          );
          remoteAudioTrack = user.audioTrack;

          // 尝试直接播放
          try {
            console.log("[SUBSCRIBE_FLOW] ?? 尝试播放到 remoteAudio 元素...");
            remoteAudioTrack.play("remoteAudio");
            console.log("[SUBSCRIBE_FLOW] ? play() 调用成功");
          } catch (err) {
            console.warn(
              "[SUBSCRIBE_FLOW] ?? play() 调用失败，可能被 autoplay 限制:",
              err
            );
          }

          // 设置音量
          const volume = Number(elements.volumeSlider.value);
          remoteAudioTrack.setVolume(volume);
          console.log("[SUBSCRIBE_FLOW] ?? 设置音量:", volume);

          // 打印用户 UID
          elements.remoteUid.textContent = user.uid || "-";
          log("Bot", `UID ${user.uid} 音频已接入`);

          // 周期性打印音频统计数据
          if (remoteAudioTrack.getStats) {
            setInterval(() => {
              const stats = remoteAudioTrack.getStats();
              console.log("[AUDIO_STATS]", {
                uid: user.uid,
                bitrate: stats?.receiveBitrate,
                packets: stats?.receivePackets,
                lossRate: stats?.receivePacketsLost,
                codec: stats?.codecType,
                isPlaying: remoteAudioTrack?.isPlaying,
              });
            }, 3000);
          }
        } catch (error) {
          console.error("[SUBSCRIBE_FLOW] ? 订阅过程中发生错误:", error);
          console.error("[SUBSCRIBE_FLOW] ?? 错误详情:", {
            message: error.message,
            code: error.code,
            stack: error.stack,
          });
          log("错误", `无法订阅 Bot 音频: ${error.message}`);
        }
      }

      function handleUserUnpublished(user, mediaType) {
        if (mediaType === "audio" && remoteAudioTrack) {
          remoteAudioTrack.stop();
          remoteAudioTrack.close();
          remoteAudioTrack = null;
          elements.remoteUid.textContent = "-";
          log("Bot", `UID ${user.uid} 已离开频道`);
        }
      }

      elements.connectButton.addEventListener("click", connect);
      elements.disconnectButton.addEventListener("click", disconnect);

      elements.volumeSlider.addEventListener("input", (event) => {
        const volume = Number(event.target.value || "70");
        elements.remoteVolume.textContent = `${volume}%`;
        if (remoteAudioTrack) {
          remoteAudioTrack.setVolume(volume);
        }
      });

      window.addEventListener("beforeunload", () => {
        if (client.connectionState !== "DISCONNECTED") {
          client.leave();
        }
      });

      log("系统", "页面加载完成，点击按钮即可体验声网 RTC 链路。");
    </script>
  </body>
</html>
